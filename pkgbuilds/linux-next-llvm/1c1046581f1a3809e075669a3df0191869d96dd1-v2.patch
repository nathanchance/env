diff --git a/arch/x86/kernel/setup.c b/arch/x86/kernel/setup.c
index 9715c8aaa845..40ed44ead063 100644
--- a/arch/x86/kernel/setup.c
+++ b/arch/x86/kernel/setup.c
@@ -757,20 +757,6 @@ dump_kernel_offset(struct notifier_block *self, unsigned long v, void *p)
 
 void __init setup_arch(char **cmdline_p)
 {
-	/*
-	 * Do some memory reservations *before* memory is added to memblock, so
-	 * memblock allocations won't overwrite it.
-	 *
-	 * After this point, everything still needed from the boot loader or
-	 * firmware or kernel text should be early reserved or marked not RAM in
-	 * e820. All other memory is free game.
-	 *
-	 * This call needs to happen before e820__memory_setup() which calls
-	 * xen_memory_setup() on Xen dom0 which relies on the fact that those
-	 * early reservations have happened already.
-	 */
-	early_reserve_memory();
-
 #ifdef CONFIG_X86_32
 	memcpy(&boot_cpu_data, &new_cpu_data, sizeof(new_cpu_data));
 
@@ -844,6 +830,20 @@ void __init setup_arch(char **cmdline_p)
 
 	x86_init.oem.arch_setup();
 
+	/*
+	 * Do some memory reservations *before* memory is added to memblock, so
+	 * memblock allocations won't overwrite it.
+	 *
+	 * After this point, everything still needed from the boot loader or
+	 * firmware or kernel text should be early reserved or marked not RAM in
+	 * e820. All other memory is free game.
+	 *
+	 * This call needs to happen before e820__memory_setup() which calls the
+	 * xen_memory_setup() on Xen dom0 which relies on the fact that those
+	 * early reservations have happened already.
+	 */
+	early_reserve_memory();
+
 	iomem_resource.end = (1ULL << boot_cpu_data.x86_phys_bits) - 1;
 	e820__memory_setup();
 	parse_setup_data();
