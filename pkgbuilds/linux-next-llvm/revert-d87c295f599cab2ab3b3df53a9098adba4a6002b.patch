diff --git a/fs/sysfs/group.c b/fs/sysfs/group.c
index ccb275cdabcb..138676463336 100644
--- a/fs/sysfs/group.c
+++ b/fs/sysfs/group.c
@@ -31,17 +31,6 @@ static void remove_files(struct kernfs_node *parent,
 			kernfs_remove_by_name(parent, (*bin_attr)->attr.name);
 }
 
-static umode_t __first_visible(const struct attribute_group *grp, struct kobject *kobj)
-{
-	if (grp->attrs && grp->is_visible)
-		return grp->is_visible(kobj, grp->attrs[0], 0);
-
-	if (grp->bin_attrs && grp->is_bin_visible)
-		return grp->is_bin_visible(kobj, grp->bin_attrs[0], 0);
-
-	return 0;
-}
-
 static int create_files(struct kernfs_node *parent, struct kobject *kobj,
 			kuid_t uid, kgid_t gid,
 			const struct attribute_group *grp, int update)
@@ -63,7 +52,6 @@ static int create_files(struct kernfs_node *parent, struct kobject *kobj,
 				kernfs_remove_by_name(parent, (*attr)->name);
 			if (grp->is_visible) {
 				mode = grp->is_visible(kobj, *attr, i);
-				mode &= ~SYSFS_GROUP_INVISIBLE;
 				if (!mode)
 					continue;
 			}
@@ -93,7 +81,6 @@ static int create_files(struct kernfs_node *parent, struct kobject *kobj,
 						(*bin_attr)->attr.name);
 			if (grp->is_bin_visible) {
 				mode = grp->is_bin_visible(kobj, *bin_attr, i);
-				mode &= ~SYSFS_GROUP_INVISIBLE;
 				if (!mode)
 					continue;
 			}
@@ -140,31 +127,16 @@ static int internal_create_group(struct kobject *kobj, int update,
 
 	kobject_get_ownership(kobj, &uid, &gid);
 	if (grp->name) {
-		umode_t mode = __first_visible(grp, kobj);
-
-		if (mode & SYSFS_GROUP_INVISIBLE)
-			mode = 0;
-		else
-			mode = S_IRWXU | S_IRUGO | S_IXUGO;
-
 		if (update) {
 			kn = kernfs_find_and_get(kobj->sd, grp->name);
 			if (!kn) {
-				pr_debug("attr grp %s/%s not created yet\n",
-					 kobj->name, grp->name);
-				/* may have been invisible prior to this update */
-				update = 0;
-			} else if (!mode) {
-				sysfs_remove_group(kobj, grp);
-				kernfs_put(kn);
-				return 0;
+				pr_warn("Can't update unknown attr grp name: %s/%s\n",
+					kobj->name, grp->name);
+				return -EINVAL;
 			}
-		}
-
-		if (!update) {
-			if (!mode)
-				return 0;
-			kn = kernfs_create_dir_ns(kobj->sd, grp->name, mode,
+		} else {
+			kn = kernfs_create_dir_ns(kobj->sd, grp->name,
+						  S_IRWXU | S_IRUGO | S_IXUGO,
 						  uid, gid, kobj, NULL);
 			if (IS_ERR(kn)) {
 				if (PTR_ERR(kn) == -EEXIST)
@@ -307,8 +279,9 @@ void sysfs_remove_group(struct kobject *kobj,
 	if (grp->name) {
 		kn = kernfs_find_and_get(parent, grp->name);
 		if (!kn) {
-			pr_debug("sysfs group '%s' not found for kobject '%s'\n",
-				 grp->name, kobject_name(kobj));
+			WARN(!kn, KERN_WARNING
+			     "sysfs group '%s' not found for kobject '%s'\n",
+			     grp->name, kobject_name(kobj));
 			return;
 		}
 	} else {
diff --git a/include/linux/sysfs.h b/include/linux/sysfs.h
index a42642b277dd..b717a70219f6 100644
--- a/include/linux/sysfs.h
+++ b/include/linux/sysfs.h
@@ -61,32 +61,22 @@ do {							\
 /**
  * struct attribute_group - data structure used to declare an attribute group.
  * @name:	Optional: Attribute group name
- *		If specified, the attribute group will be created in a
- *		new subdirectory with this name. Additionally when a
- *		group is named, @is_visible and @is_bin_visible may
- *		return SYSFS_GROUP_INVISIBLE to control visibility of
- *		the directory itself.
+ *		If specified, the attribute group will be created in
+ *		a new subdirectory with this name.
  * @is_visible:	Optional: Function to return permissions associated with an
- *		attribute of the group. Will be called repeatedly for
- *		each non-binary attribute in the group. Only read/write
+ *		attribute of the group. Will be called repeatedly for each
+ *		non-binary attribute in the group. Only read/write
  *		permissions as well as SYSFS_PREALLOC are accepted. Must
- *		return 0 if an attribute is not visible. The returned
- *		value will replace static permissions defined in struct
- *		attribute. Use SYSFS_GROUP_VISIBLE() when assigning this
- *		callback to specify separate _group_visible() and
- *		_attr_visible() handlers.
+ *		return 0 if an attribute is not visible. The returned value
+ *		will replace static permissions defined in struct attribute.
  * @is_bin_visible:
  *		Optional: Function to return permissions associated with a
  *		binary attribute of the group. Will be called repeatedly
  *		for each binary attribute in the group. Only read/write
- *		permissions as well as SYSFS_PREALLOC (and the
- *		visibility flags for named groups) are accepted. Must
- *		return 0 if a binary attribute is not visible. The
- *		returned value will replace static permissions defined
- *		in struct bin_attribute. If @is_visible is not set, Use
- *		SYSFS_GROUP_VISIBLE() when assigning this callback to
- *		specify separate _group_visible() and _attr_visible()
- *		handlers.
+ *		permissions as well as SYSFS_PREALLOC are accepted. Must
+ *		return 0 if a binary attribute is not visible. The returned
+ *		value will replace static permissions defined in
+ *		struct bin_attribute.
  * @attrs:	Pointer to NULL terminated list of attributes.
  * @bin_attrs:	Pointer to NULL terminated list of binary attributes.
  *		Either attrs or bin_attrs or both must be provided.
@@ -101,42 +91,13 @@ struct attribute_group {
 	struct bin_attribute	**bin_attrs;
 };
 
-#define SYSFS_PREALLOC		010000
-#define SYSFS_GROUP_INVISIBLE	020000
-
-/*
- * The first call to is_visible() in the create / update path may
- * indicate visibility for the entire group
- */
-#define DEFINE_SYSFS_GROUP_VISIBLE(name)                             \
-	static inline umode_t sysfs_group_visible_##name(            \
-		struct kobject *kobj, struct attribute *attr, int n) \
-	{                                                            \
-		if (n == 0 && !name##_group_visible(kobj))           \
-			return SYSFS_GROUP_INVISIBLE;                \
-		return name##_attr_visible(kobj, attr, n);           \
-	}
-
-/*
- * Same as DEFINE_SYSFS_GROUP_VISIBLE, but for groups with only binary
- * attributes
- */
-#define DEFINE_SYSFS_BIN_GROUP_VISIBLE(name)                             \
-	static inline umode_t sysfs_group_visible_##name(                \
-		struct kobject *kobj, struct bin_attribute *attr, int n) \
-	{                                                                \
-		if (n == 0 && !name##_group_visible(kobj))               \
-			return SYSFS_GROUP_INVISIBLE;                    \
-		return name##_attr_visible(kobj, attr, n);               \
-	}
-
-#define SYSFS_GROUP_VISIBLE(fn) sysfs_group_visible_##fn
-
 /*
  * Use these macros to make defining attributes easier.
  * See include/linux/device.h for examples..
  */
 
+#define SYSFS_PREALLOC 010000
+
 #define __ATTR(_name, _mode, _show, _store) {				\
 	.attr = {.name = __stringify(_name),				\
 		 .mode = VERIFY_OCTAL_PERMISSIONS(_mode) },		\
