#!/usr/bin/env bash
# SPDX-License-Identifier: GPL-3.0-or-later
#
# Shebang is purely for syntax highlighting and shellcheck auditing; script must be sourced to be useful
#
# Copyright (C) 2019-2021 Nathan Chancellor
#
# Raspberry Pi environment script
#
# $ sudo sh -c "apt update && apt dist-upgrade -y && apt install --no-install-recommends -y zsh && chsh -s /bin/zsh pi"

function bkrnl() { (
    set -x

    PO=${SSD_TC}/llvm-binutils/bin \
        make.sh \
        -C "${SSD_SRC}"/linux-next \
        LLVM=1 \
        LLVM_IAS=1 \
        "${@}" \
        distclean defconfig all
); }

function bkrnls() { (
    bkrnl O=build/"$(uname -m)" || exit ${?}
    [[ $(uname -m) = "aarch64" ]] && bkrnl ARCH=x86_64 CROSS_COMPILE=x86_64-linux-gnu- O=build/x86_64
); }

# Build LLVM then kernels
function bldall() { (
    upd_lnx_nxt || exit ${?}
    bldtcs || exit ${?}
    bkrnls || exit ${?}
    bootk "" || exit ${?}
    "${SSD_SRC}"/boot-utils/boot-qemu.sh -a x86_64 -k "${SSD_SRC}"/linux-next/build/x86_64
); }

# Build LLVM and binutils
function bldtcs() { (
    DATE_TIME=$(date +%F_%H-%M-%S)

    # Update tc-build
    TCBLD=${SSD_SRC}/tc-build
    [[ -d ${TCBLD} ]] || git clone -b personal https://github.com/nathanchance/tc-build.git "${TCBLD}"
    cd "${TCBLD}" || die "Error downloading tc-build"
    git ru
    git rh origin/"$(git cb)"

    # Build binutils
    TC_BLD_BNTLS=${TCBLD}/binutils
    [[ -d ${TC_BLD_BNTLS} ]] || git clone https://sourceware.org/git/binutils-gdb.git "${TC_BLD_BNTLS}"
    git -C "${TC_BLD_BNTLS}" pull --rebase || die "Updating binutils failed (${?})"
    BLDBN_INSTALL_FOLDER=${SSD_TC}/binutils-${DATE_TIME}-$(git -C "${TC_BLD_BNTLS}" sh -s --format=%H origin/master)
    "${TCBLD}"/build-binutils.py \
        --install-folder "${BLDBN_INSTALL_FOLDER}" \
        --targets host x86_64 || die "bldbn failed with exit code ${?}"
    stripall "${BLDBN_INSTALL_FOLDER}"

    # Update binutils
    ln -fnrsv "${BLDBN_INSTALL_FOLDER}" "${SSD_TC}"/binutils-latest

    # Build LLVM/Clang/lld
    TC_BLD_LLVM_PRJCT=${TCBLD}/llvm-project
    [[ -d ${TC_BLD_LLVM_PRJCT} ]] || git clone https://github.com/llvm/llvm-project "${TC_BLD_LLVM_PRJCT}"
    git -C "${TC_BLD_LLVM_PRJCT}" pull --rebase || die "Updating llvm-project failed (${?})"
    BLDLLVM_INSTALL_FOLDER=${SSD_TC}/llvm-${DATE_TIME}-$(git -C "${TC_BLD_LLVM_PRJCT}" sh -s --format=%H origin/main)
    PATH=${SSD_TC}/llvm-latest/bin:${PATH} \
        "${TCBLD}"/build-llvm.py \
        --assertions \
        --build-stage1-only \
        --check-targets clang llvm llvm-unit \
        --install-folder "${BLDLLVM_INSTALL_FOLDER}" \
        --install-stage1-only \
        --projects "clang;lld" \
        --targets "AArch64;ARM;X86" || die "bldllvm failed with exit code ${?}"
    stripall "${BLDLLVM_INSTALL_FOLDER}"

    # Update llvm-latest symlink
    ln -fnrsv "${BLDLLVM_INSTALL_FOLDER}" "${SSD_TC}"/llvm-latest

    # Combine binutils-latest and llvm-latest for easy testing
    stow -d "${SSD_TC}" -R -t "${SSD_TC}"/llvm-binutils -v binutils-latest
    stow -d "${SSD_TC}" -R -t "${SSD_TC}"/llvm-binutils -v llvm-latest
); }

function bootk() { (
    BOOT_UTILS=${SSD_SRC}/boot-utils
    [[ -d ${BOOT_UTILS} ]] || git clone https://github.com/ClangBuiltLinux/boot-utils "${BOOT_UTILS}"
    git -C "${BOOT_UTILS}" pull -q

    while ((${#})); do
        case ${1} in
            -a | --arch)
                shift
                ARCH=${1}
                ;;

            -k | --kernel)
                [[ ${#} -gt 0 ]] && shift
                KERNEL_IMG=${1:-/boot/custom-next-testing-arm64/Image}
                KERNEL_LOCATION=${SSD}/booting-kernel
                mkdir -p "${KERNEL_LOCATION}"/arch/arm64/boot

                # This matches the kernel command to create Image.gz
                # shellcheck disable=SC2002
                cat "${KERNEL_IMG}" | pigz -n -f -9 >"${KERNEL_LOCATION}"/arch/arm64/boot/Image.gz
                ;;
        esac
        [[ ${#} -gt 0 ]] && shift
    done

    set -x

    "${BOOT_UTILS}"/boot-qemu.sh -a "${ARCH:-arm64}" -k "${KERNEL_LOCATION:-${SSD_SRC}/linux-next/build/"$(uname -m)"}"
); }

function bootstrap() { (
    source <(curl -LSs https://github.com/nathanchance/scripts/raw/main/common) &>/dev/null || exit ${?}
    source <(curl -LSs https://github.com/nathanchance/scripts/raw/main/env/stubs/folders) &>/dev/null || exit ${?}

    # Get list of packages to be installed
    # Debian/Ubuntu
    PACKAGES=(
        bc
        bison
        build-essential
        ca-certificates
        clang
        clang-format
        cmake
        creduce
        curl
        devscripts
        doxygen
        expect
        fakeroot
        file
        flex
        gcc
        gettext
        git
        g++
        jq
        libauthen-sasl-perl
        libclang-dev
        libcurl4-openssl-dev
        libedit-dev
        libelf-dev
        libemail-valid-perl
        libevent-dev
        libexpat1-dev
        libglib2.0-dev
        libgmp-dev
        libio-socket-ssl-perl
        libmailtools-perl
        libmpc-dev
        libmpfr-dev
        libncurses-dev
        libnet-smtp-ssl-perl
        libpcre2-dev
        libpixman-1-dev
        libssl-dev
        lld
        llvm
        llvm-dev
        locales
        make
        mosh
        most
        neofetch
        ninja-build
        pigz
        pkg-config
        psmisc
        python2.7
        python3
        python3-dev
        python3-pip
        qemu-system-arm
        qemu-system-x86
        ruby-dev
        stow
        swig
        texinfo
        tcl
        tmux
        u-boot-tools
        unifdef
        unzip
        vim
        zip
        zlib1g-dev
        zsh
        zstd
    )

    # If we are root, install sudo so that we don't need a separate set of
    # commands whether we are root or a regular user
    if [[ $(id -u) -eq 0 ]]; then
        apt update || exit ${?}
        apt install -y sudo || exit ${?}
    fi

    sudo apt update || exit ${?}
    sudo DEBIAN_FRONTEND=noninteractive apt upgrade -y || exit ${?}
    sudo DEBIAN_FRONTEND=noninteractive apt install --no-install-recommends -y "${PACKAGES[@]}" || exit ${?}
    sudo DEBIAN_FRONTEND=noninteractive apt install --no-install-recommends -y python-is-python3 2>/dev/null
    echo "locales locales/default_environment_locale select en_US.UTF-8" | sudo debconf-set-selections
    echo "locales locales/locales_to_be_generated multiselect en_US.UTF-8 UTF-8" | sudo debconf-set-selections
    sudo rm "/etc/locale.gen"
    sudo dpkg-reconfigure --frontend noninteractive locales
    grep -q configs /etc/modules || printf 'configs\nsnd_bcm2835\n' | sudo tee -a /etc/modules
    sudo usermod -a -G kvm "$(id -un)"
    sudo raspi-config --expand-rootfs
    sudo raspi-config nonint do_serial 0

    SCRIPTS=${GITHUB_FOLDER}/scripts
    mkdir -p "${GITHUB_FOLDER}"
    [[ -d ${SCRIPTS} ]] || { git clone https://github.com/nathanchance/scripts "${SCRIPTS}" || die "Error cloning scripts!"; }
    git -C "${SCRIPTS}" pull --rebase || die "Error updating script!"
    source <(cat "${SCRIPTS}"/env/common)
    source "${SCRIPTS}"/env/stubs/zsh && setup_zsh_env
    # SC2016: Expressions don't expand in single quotes, use double quotes for that.
    # That is indeed the point here :)
    # shellcheck disable=SC2016
    sed -i '1s;^;[[ $(tty) =~ ttyS1 ]] \&\& return\n;' "${HOME}"/.zshrc
    source "${SCRIPTS}"/env/stubs/setup && global_gitignore
    SCRIPTS_FOLDER=${SCRIPTS} rbld_usr || exit ${?}
    path_push "${HOME}/usr/bin"
    source "${SCRIPTS}"/env/stubs/git && git_setup
    zsh "${SCRIPTS}"/configs/common/vim/vim_setup.sh
    ln -fs "${SCRIPTS}"/configs/workstation/.tmux.conf "${HOME}"/.tmux.conf

    echo "TODO:"
    echo
    echo "1. ssh-copy-id"
    echo
    echo "2. Download .server_ip"
    echo
    echo "3. Handle SSD if necessary"
); }

function clmods() { (
    FD_ARGS=(-d 1 -E "$(uname -r)")
    while IFS=$'\n' read -r STOCK_MODULES; do
        FD_ARGS+=(-E "$(basename "${STOCK_MODULES%-*}")*+")
    done < <(fd -- '-v7l\+' /lib/modules)

    fd "${FD_ARGS[@]}" . /lib/modules -x sudo rm -frv
); }

# Function to properly show host with pure
function fixp() {
    eval "$(tmux show-env -s SSH_CONNECTION)" && prompt pure
}

function pi_setup() {
    export SSD=/mnt/ssd
    export SSD_SRC=${SSD}/src
    export SSD_TC=${SSD}/toolchains
}

function rbld_usr() { (
    source "${SCRIPTS_FOLDER:?}"/env/stubs/updbin || die "Cannot source updbin"

    # Clean up PREFIX
    RBLD_USR_PREFIX=${PREFIX:-${USR_FOLDER:?}}
    RBLD_USR_STOW=${RBLD_USR_PREFIX}/stow
    if [[ -d ${RBLD_USR_STOW} ]]; then (
        header "Cleaning up stow directory"
        cd "${RBLD_USR_STOW}" || exit ${?}
        for PACKAGE in *-latest prebuilts; do [[ -d ${PACKAGE} ]] && stow -D -v "${PACKAGE}"; done
    ); fi
    rm -rf "${RBLD_USR_PREFIX:?}"/{bin,doc,include,lib,libexec,share}
    mkdir -p "${RBLD_USR_STOW}"

    bccache || die "Error building/installing ccache"
    bgit || die "Error building/installing git"
    bmake || die "Error building/installing make"
    biexa || die "Error building/installing exa"
    birg || die "Error building/install ripgrep"
    bisharkdp all || die "Error building/installing a sharkdp binary"
    btmux || die "Error building/installing tmux"
    bzsh || die "Error building/installing zsh"
); }

# Strip executables within a folder
function stripall() { (
    cd "${1:?}" || exit ${?}
    for FILE in $(fd -t file -x file | grep 'not stripped' | cut -d: -f1); do strip "${FILE}"; done
); }

# Update kernel from build server
function upd_kernel() { (
    while ((${#})); do
        case ${1} in
            4.* | 5.* | mainline* | next*) VER=${1} ;;
            arm | arm64) ARCH=${1} ;;
            *) die "Unknown parameter '${1}'" ;;
        esac
        shift
    done

    TMP_BOOT=$(mktemp -d)
    MAIN_BOOT=/boot/custom-${VER:=5.4}-${ARCH:=arm64}

    mkdir -p "${TMP_BOOT}"/modules

    case ${ARCH} in
        arm)
            DTBS=/
            KERNEL=zImage
            ;;
        arm64)
            DTBS=broadcom/
            KERNEL=Image
            ;;
    esac

    USER=nathan
    OUT=/home/${USER}/cbl/build/rpi/build/${ARCH}
    ROOTFS=${OUT}/rootfs
    { rsync -v ${USER}@"${SERVER_IP}":"${ROOTFS}"/"${DTBS}"'*.dtb' "${TMP_BOOT}" &&
        rsync -vr ${USER}@"${SERVER_IP}":"${ROOTFS}"/lib/modules/'*' "${TMP_BOOT}"/modules &&
        rsync -v ${USER}@"${SERVER_IP}":"${OUT}"/arch/"${ARCH}"/boot/"${KERNEL}" "${TMP_BOOT}"; } || exit ${?}

    if [[ ! ${VER} =~ mainline && ! ${VER} =~ next ]]; then
        mkdir -p "${TMP_BOOT}"/overlays
        rsync -v ${USER}@"${SERVER_IP}":"${ROOTFS}"/overlays/'*.dtb*' "${TMP_BOOT}"/overlays || exit ${?}
    fi

    # Move modules
    MOD_DIR=$(fd -d 1 . "${TMP_BOOT}"/modules)
    : "${MOD_DIR:?}"
    sudo rm -vrf /lib/modules/"${MOD_DIR##*/}"
    sudo mv -v "${MOD_DIR}" /lib/modules
    sudo rmdir -v "${TMP_BOOT}"/modules

    # Move all other files
    sudo rm -vrf "${MAIN_BOOT}"
    sudo mv -v "${TMP_BOOT}" "${MAIN_BOOT}"

    # Copy cmdline.txt because we are modifying os_prefix
    sudo cp -v /boot/cmdline.txt "${MAIN_BOOT}"

    # Ensure that there is always a serial console option
    if ! grep -q -e ttyS1 -e serial0 "${MAIN_BOOT}"/cmdline.txt; then
        case "${VER}" in
            4.* | 5.*) CONSOLE=serial0 ;;
            mainline* | next*) CONSOLE=ttyS1 ;;
        esac
        CMDLINE="console=${CONSOLE},115200 $(cat "${MAIN_BOOT}"/cmdline.txt)"
        printf "%s\n" "${CMDLINE}" | sudo tee "${MAIN_BOOT}"/cmdline.txt
    else
        [[ ${VER} =~ mainline || ${VER} =~ next ]] && sudo sed -i 's/serial0/ttyS1/' "${MAIN_BOOT}"/cmdline.txt
    fi

    # Remove "quiet" and "splash" from cmdline
    sudo sed -i 's/quiet splash //' "${MAIN_BOOT}"/cmdline.txt
); }

function upd_lnx_nxt() { (
    LINUX_NEXT=${SSD_SRC}/linux-next
    [[ -d ${LINUX_NEXT} ]] || git clone https://git.kernel.org/pub/scm/linux/kernel/git/next/linux-next.git/ "${LINUX_NEXT}"
    git -C "${LINUX_NEXT}" ru
    git -C "${LINUX_NEXT}" rb -i origin/master
); }
# vi: filetype=zsh
