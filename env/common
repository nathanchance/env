# SPDX-License-Identifier: GPL-3.0-or-later
#
# Copyright (C) 2017-2019 Nathan Chancellor
#
# Utility and terminal setup functions


# Source our universal functions script
if [[ -n ${ZSH_NAME} ]]; then
    SCRIPT=${(%):-%x}
elif [[ -n ${BASH} ]]; then
    SCRIPT=${BASH_SOURCE[0]}
else
    echo "Unsupported shell!"
    return 1
fi
source "$(cd "$(dirname "$(readlink -f "${SCRIPT}")")" || return; pwd)/../common"
unset SCRIPT


# Source the machine specific functions
case "$(whoami)@$(uname -n)" in
    "u0_a"*"@localhost") LOCATION=android ;;
    "natechancellor@penguin"|"nathan@localhost") LOCATION=chromeos ;;
    "nathan@archlinux-"*|"nathan@flashbox") LOCATION=server ;;
esac
source "${SCRIPTS_FOLDER}/env/${LOCATION}"


# Universal aliases/functions
function aliases() {
    # tmux alias
    command -v tmux &>/dev/null && alias tmux='tmux -u'

    # hub alias
    if command -v hub > /dev/null 2>&1; then alias git='hub'; fi

    source "${SCRIPTS_FOLDER}/funcs/bldupdbin"
    source "${SCRIPTS_FOLDER}/funcs/deldog"
    source "${SCRIPTS_FOLDER}/funcs/git"
    source "${SCRIPTS_FOLDER}/funcs/transfer"
}


# Try to attach via tmux
function tmxa() {
    command -v tmux &>/dev/null || return
    [[ -z ${TMUX} ]] && tmux new-session -AD -s main
}


# Smart tmux detach
# https://arslan.io/2019/01/07/using-the-ipad-pro-as-my-development-machine/
function tmxd() {
    local COUNT PANES WINS

    command -v tmux &>/dev/null || return
    [[ -z ${TMUX} ]] && builtin exit

    PANES=$(tmux list-panes | wc -l)
    WINS=$(tmux list-windows | wc -l)
    COUNT=$((PANES + WINS - 1))
    if [[ ${COUNT} -eq 1 ]]; then
        tmux detach
    else
        builtin exit
    fi
}


# Add something to the end of PATH if it isn't already there
function add_to_path_post() {
    local ARRAY ITEM
    IFS=: read -rA ARRAY <<< "${1}"
    for ITEM in $(printf '%s\n' "${ARRAY[@]}" | tac); do
        [[ -d ${ITEM} ]] || continue
        echo "${PATH}" | grep -s -q "${ITEM}" || export PATH="${PATH}:${ITEM}"
    done
}


# Does the same thing as add_to_path_pre but doesn't check if item exists or not
function move_to_front_of_path() {
    local ARRAY ITEM
    IFS=: read -rA ARRAY <<< "${1}"
    for ITEM in $(printf '%s\n' "${ARRAY[@]}" | tac); do
        [[ -d ${ITEM} ]] || continue
        export PATH="${ITEM}:${PATH//${ITEM}:}"
    done
}


# Add something to the beginning of PATH if it isn't already there
function add_to_path_pre() {
    local ARRAY ITEM
    IFS=: read -rA ARRAY <<< "${1}"
    for ITEM in $(printf '%s\n' "${ARRAY[@]}" | tac); do
        [[ -d ${ITEM} ]] || continue
        echo "${PATH}" | grep -s -q "${ITEM}" || export PATH="${ITEM}:${PATH}"
    done
}
# Easy alias
function path_push() { add_to_path_pre "${@}"; }


# Delete the first folder in PATH
function path_pop() {
    export PATH=${PATH#*:}
}


function shell_setup() {
    # Shell specific options
    if [[ -n ${ZSH_NAME} ]]; then
        [[ -n ${terminfo[khome]} ]] && bindkey "${terminfo[khome]}" beginning-of-line
        [[ -n ${terminfo[kend]} ]] && bindkey "${terminfo[kend]}" end-of-line

        setopt autocd
        typeset -gU path

        echo "$fpath" | grep -q -s "${HOME}/.zfunctions" || fpath=( "${HOME}/.zfunctions" $fpath )

        export HISTSIZE=100000
        export PURE_GIT_PULL=0
        export TIMEFMT=$'\nreal\t%*E\nuser\t%*U\nsys\t%*S'

        [[ -f ${HOME}/usr/share/bash-completion/completions/git ]] && \
            zstyle ':completion:*:*:git:*' script "${HOME}"/usr/share/bash-completion/completions/git

        autoload -U compinit && compinit
        autoload -U promptinit && promptinit && prompt pure
    elif [[ -n ${BASH} ]]; then
        shopt -s checkwinsize
    else
        echo "Unsupported shell!"
        return 1
    fi

    # Environment setup
    path_push "${HOME}/usr/bin"
    aliases
    "${LOCATION}"_aliases
    tmxa
    "${LOCATION}"_setup
    GPG_TTY=$(tty); export GPG_TTY
}


# {bash,zsh}rc reload function
function rld() {
    source "${SCRIPTS_FOLDER}/env/common"
    shell_setup
}


# Bind mount current PWD into Docker container
function docker_mount() {
    docker run --mount type=bind,source="${PWD}",target=/"${PWD##*/}",readonly \
               --workdir /"${PWD##*/}" \
               "${@}"
}


# Set common architecture variable
function get_arch() {(
    case "$(uname -m)" in
        "aarch64") echo "arm64" ;;
        "x86_64") echo "amd64" ;;
        *) exit 1 ;;
    esac
)}
# vi: filetype=zsh
