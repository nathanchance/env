#!/usr/bin/env bash
# SPDX-License-Identifier: MIT
#
# Shebang is purely for syntax highlighting and shellcheck auditing; script must be sourced to be useful
#
# Copyright (C) 2019-2021 Nathan Chancellor
#
# Functions to build the latest versions of certain pieces of software

#######################
#  BUILD FROM SOURCE  #
#######################

# Build/update ccache
function bccache() { (
    header "Building ccache"

    # Variables for function
    CCACHE_REPO=ccache/ccache
    [[ -z ${CCACHE_VERSION} ]] && CCACHE_VERSION=$(glr "${CCACHE_REPO}")
    CCACHE_SRC=${SRC_FOLDER:?}/ccache/ccache-${CCACHE_VERSION//v/}
    CCACHE_STOW=${PREFIX:-${USR_FOLDER:?}}/stow
    CCACHE_PREFIX=${CCACHE_STOW}/packages/ccache/$(date +%F-%H-%M-%S)-${CCACHE_VERSION//v/}

    # Download source
    mkdir -p "${CCACHE_SRC%/*}"
    [[ -d ${CCACHE_SRC} ]] || curl -LSs https://github.com/"${CCACHE_REPO}"/releases/download/"${CCACHE_VERSION}"/"${CCACHE_SRC##*/}".tar.gz | tar -C "${CCACHE_SRC%/*}" -xzf -

    # Prepare build folder
    CCACHE_BUILD=${CCACHE_SRC}/build
    rm -rf "${CCACHE_BUILD}"
    mkdir -p "${CCACHE_BUILD}"
    cd "${CCACHE_BUILD}" || die "Could not create build folder"

    # Build software
    mkdir -p "${CCACHE_PREFIX%/*}"
    cmake \
        -DCMAKE_BUILD_TYPE=Release \
        -DCMAKE_INSTALL_PREFIX="${CCACHE_PREFIX}" \
        -DZSTD_FROM_INTERNET=ON .. || die "cmake configuration failed"
    make "${JOBS_FLAG}" install || die "make install failed"

    # Update symlink and stow new package
    ln -fnrsv "${CCACHE_PREFIX}" "${CCACHE_STOW}"/ccache-latest
    stow -d "${CCACHE_STOW}" -R -v ccache-latest

    # Print information about new binary
    move_to_front_of_path "${CCACHE_STOW%/*}"/bin
    command -v ccache
    ccache --version
); }

# Build/update cmake
function bcmake() { (
    header "Building cmake"

    # Variables for function
    CMAKE_REPO=Kitware/CMake
    [[ -z ${CMAKE_VERSION} ]] && CMAKE_VERSION=$(glr "${CMAKE_REPO}")
    CMAKE_SRC=${SRC_FOLDER:?}/cmake/cmake-${CMAKE_VERSION//v/}
    CMAKE_STOW=${PREFIX:-${USR_FOLDER:?}}/stow
    CMAKE_PREFIX=${CMAKE_STOW}/packages/cmake/$(date +%F-%H-%M-%S)-${CMAKE_VERSION//v/}

    # Download source
    mkdir -p "${CMAKE_SRC%/*}"
    [[ -d ${CMAKE_SRC} ]] || curl -LSs https://github.com/"${CMAKE_REPO}"/releases/download/"${CMAKE_VERSION}"/"${CMAKE_SRC##*/}".tar.gz | tar -C "${CMAKE_SRC%/*}" -xzf -

    # Build software
    cd "${CMAKE_SRC}" || die "Downloading or extracting cmake failed"
    ./bootstrap \
        --parallel="$(nproc)" \
        --prefix="${CMAKE_PREFIX}"
    make "${JOBS_FLAG}" install || die "make failed"

    # Update symlink and stow new package
    ln -fnrsv "${CMAKE_PREFIX}" "${CMAKE_STOW}"/cmake-latest
    stow -d "${CMAKE_STOW}" -R -v cmake-latest

    # Print information about new binary
    move_to_front_of_path "${CMAKE_STOW%/*}"/bin
    command -v cmake
    cmake --version
); }

# Build/update cvise
function bcvise() { (
    # Find distribution version of LLVM (special handling for Debian / Ubuntu)
    for LLVM_VER in $(seq 20 -1 7); do
        LLVM_DIR=/usr/lib/llvm-${LLVM_VER}
        if [[ -d ${LLVM_DIR} ]]; then
            CMAKE_PREFIX_PATH=${LLVM_DIR}
            break
        fi
    done
    [[ -z ${CMAKE_PREFIX_PATH} ]] && CMAKE_PREFIX_PATH=/usr

    if [[ $("${SCRIPTS_FOLDER}"/external/cc-version.sh "${CMAKE_PREFIX_PATH}"/bin/clang | awk '{print $2}') -lt 90000 ]]; then
        header "Skipping cvise due to older clang"
        exit 0
    fi

    header "Building cvise"

    # Variables for function
    CVISE_REPO=marxin/cvise
    [[ -z ${CVISE_VERSION} ]] && CVISE_VERSION=$(glr ${CVISE_REPO})
    CVISE_SRC=${SRC_FOLDER:?}/cvise/cvise-${CVISE_VERSION//v/}
    CVISE_STOW=${PREFIX:-${USR_FOLDER:?}}/stow
    CVISE_PREFIX=${CVISE_STOW}/packages/cvise/$(date +%F-%H-%M-%S)-${CVISE_VERSION//v/}

    # Download source
    mkdir -p "${CVISE_SRC%/*}"
    [[ -d ${CVISE_SRC} ]] || curl -LSs https://github.com/${CVISE_REPO}/archive/v"${CVISE_VERSION//v/}".tar.gz | tar -C "${CVISE_SRC%/*}" -xzf -

    # Download and install dependencies
    python3 -m pip install --upgrade --user pebble pytest
    path_push "${HOME}"/.local/bin

    # Prepare build folder
    CVISE_BLD=${CVISE_SRC}/build
    rm -rf "${CVISE_BLD}"
    mkdir -p "${CVISE_BLD}"
    cd "${CVISE_BLD}" || die "Error creating build folder"

    # Build software
    cmake \
        -DCMAKE_C_COMPILER="$(command -v clang || command -v gcc)" \
        -DCMAKE_CXX_COMPILER="$(command -v clang++ || command -v g++)" \
        -DCMAKE_INSTALL_PREFIX="${CVISE_PREFIX}" \
        -DCMAKE_PREFIX_PATH=${CMAKE_PREFIX_PATH} \
        -DPYTHON_EXECUTABLE="$(command -v python3)" \
        .. || die "Error configuring cvise"
    make "${JOBS_FLAG}" install || die "Error building cvise"

    # Update symlink and stow new package
    ln -fnrsv "${CVISE_PREFIX}" "${CVISE_STOW}"/cvise-latest
    stow -d "${CVISE_STOW}" -R -v cvise-latest

    # Print information about new binary
    move_to_front_of_path "${CVISE_STOW%/*}"/bin
    command -v cvise
    cvise --version
); }

# Build/update dtc
function bdtc() { (
    header "Building dtc"

    # Download source
    DTC_FOLDER=${SRC_FOLDER:?}/dtc
    if [[ ! -d ${DTC_FOLDER} ]]; then
        mkdir -p "${DTC_FOLDER%/*}"
        git clone https://git.kernel.org/pub/scm/utils/dtc/dtc.git "${DTC_FOLDER}"
    fi
    cd "${DTC_FOLDER}" || die "Couldn't move into ${DTC_FOLDER}"

    # Clean up from previous compiles and update repo
    git clean -fxdq
    git fetch
    [[ -z ${DTC_VERSION} ]] && DTC_VERSION=$(git describe --tags "$(git rev-list --tags --max-count=1)")
    git checkout v"${DTC_VERSION//v/}"

    # Path variables
    DTC_STOW=${PREFIX:-${USR_FOLDER:?}}/stow
    DTC_PREFIX=${DTC_STOW}/packages/dtc/$(date +%F-%H-%M-%S)-${DTC_VERSION//v/}

    # Build software
    mkdir -p "${DTC_PREFIX%/*}"
    make "${JOBS_FLAG}" NO_PYTHON=1 PREFIX="${DTC_PREFIX}" install

    # Update symlink and stow new package
    ln -fnrsv "${DTC_PREFIX}" "${DTC_STOW}"/dtc-latest
    stow -d "${DTC_STOW}" -R -v dtc-latest

    # Print information about new binary
    move_to_front_of_path "${DTC_STOW%/*}"/bin
    command -v dtc
    dtc --version
); }

# Build/update git
function bgit() { (
    # Install hub first in case git is an alias to hub
    ihub || exit ${?}

    header "Building git"

    # If we are on x86, we should tune for native
    [[ $(uname -m) =~ x86 ]] && MARCH="-march=native "

    # Variables for function

    # Make variable
    # Taken from https://github.com/archlinux/svntogit-packages/blob/packages/git/trunk/PKGBUILD
    MAKE=(
        make
        "${JOBS_FLAG}"
        CFLAGS="${MARCH}-O2 -pipe -fstack-protector-strong -fno-plt"
        LDFLAGS="-Wl,-O1,--sort-common,--as-needed,-z,relro,-z,now"
        INSTALL_SYMLINKS=1
        NO_PERL_CPAN_FALLBACKS=1
        USE_LIBPCRE2=1
    )

    # Download/update source
    GIT_FOLDER=${SRC_FOLDER:?}/git
    if [[ ! -d ${GIT_FOLDER} ]]; then
        mkdir -p "${GIT_FOLDER%/*}"
        git clone https://git.kernel.org/pub/scm/git/git.git "${GIT_FOLDER}"
    fi
    cd "${GIT_FOLDER}" || die "Couldn't move into ${GIT_FOLDER}"
    git clean -fxdq
    git pull --rebase

    # Path variables
    GIT_STOW=${PREFIX:-${USR_FOLDER:?}}/stow
    GIT_PREFIX=${GIT_STOW}/packages/git/$(date +%F-%H-%M-%S)-$(git show -s --format=%H)

    # Build and install software + completions
    "${MAKE[@]}" prefix="${GIT_PREFIX}" all install || die "git build/install failed"
    if [[ -n ${ZSH_NAME} ]]; then
        install -Dm644 "${GIT_FOLDER}"/contrib/completion/git-completion.bash "${GIT_PREFIX}"/share/bash-completion/completions/git
        install -Dm644 "${GIT_FOLDER}"/contrib/completion/git-completion.zsh "${HOME}"/.zfunctions/_git
    fi

    # Update symlink and stow new package
    ln -fnrsv "${GIT_PREFIX}" "${GIT_STOW}"/git-latest
    stow -d "${GIT_STOW}" -R -v git-latest

    # Print information about new binary
    move_to_front_of_path "${GIT_STOW%/*}"/bin
    command -v git
    git --version
); }

# Build a full LLVM toolchain
function bllvm() { (
    TC_BLD_ARGS=()
    while ((${#})); do
        case ${1} in
            --lto)
                TC_BLD_ARGS+=(--lto thin)
                ;;
            --pgo)
                TC_BLD_ARGS+=(--pgo llvm)
                ;;
            --prefix)
                shift
                LLVM_PREFIX=${1}
                ;;
            --qualify-two-stages)
                LLVM_PREFIX=$(mktemp -d -p "${TMP_FOLDER}")
                INSTALL=false
                ;;
            --qualify)
                TC_BLD_ARGS+=(--build-stage1-only)
                ;;
        esac
        shift
    done

    TC_BLD=${SRC_FOLDER}/tc-build
    header "Updating/cloning tc-build"
    [[ -d ${TC_BLD} ]] || git clone https://github.com/ClangBuiltLinux/tc-build "${TC_BLD}"
    git -C "${TC_BLD}" pull --rebase

    LLVM_SRC=${TC_BLD}/llvm-project
    if [[ ! -d ${LLVM_SRC} ]]; then
        header "Cloning LLVM"
        git clone https://github.com/llvm/llvm-project "${LLVM_SRC}" || exit ${?}
    fi

    if [[ -z ${LLVM_PREFIX} ]]; then
        LLVM_STOW=${PREFIX:-${USR_FOLDER:?}}/stow
        LLVM_PREFIX=${LLVM_STOW}/packages/llvm/$(date +%F-%H-%M-%S)-$(git -C "${LLVM_SRC}" sh -s --format=%H origin/main)
    fi

    set -x
    "${TC_BLD}"/build-llvm.py \
        --check-targets clang lld llvm llvm-unit \
        --clang-vendor "$(uname -n)" \
        --defines CLANG_DEFAULT_LINKER=lld \
        --full-toolchain \
        --install-folder "${LLVM_PREFIX}" \
        --no-update \
        --show-build-commands \
        --projects "$(llvm_all_projects "${LLVM_SRC}")" \
        "${TC_BLD_ARGS[@]}" || exit ${?}
    set +x

    if ${INSTALL:=false}; then
        ln -fnrsv "${LLVM_PREFIX}" "${LLVM_STOW}"/llvm-latest
        stow -d "${LLVM_STOW}" -R -v llvm-latest
    fi
); }

# Build/install GNU make
function bmake() { (
    header "Building make"

    # Variables for function
    [[ -z ${MAKE_VERSION} ]] && MAKE_VERSION=4.3
    MAKE_SRC=${SRC_FOLDER:?}/make/make-${MAKE_VERSION}
    MAKE_STOW=${PREFIX:-${USR_FOLDER:?}}/stow
    MAKE_PREFIX=${MAKE_STOW}/packages/make/$(date +%F-%H-%M-%S)-${MAKE_VERSION}

    # Download source
    mkdir -p "${MAKE_SRC%/*}"
    [[ -d ${MAKE_SRC} ]] || curl -LSs http://ftp.gnu.org/gnu/make/"${MAKE_SRC##*/}".tar.gz | tar -C "${MAKE_SRC%/*}" -xzf -

    # Build software
    cd "${MAKE_SRC}" || die "Downloading or extracting make failed"
    ./configure --prefix="${MAKE_PREFIX}" || die "Error configuring make"
    make "${JOBS_FLAG}" install || die "Error building make"

    # Update symlink and stow new package
    ln -fnrsv "${MAKE_PREFIX}" "${MAKE_STOW}"/make-latest
    stow -d "${MAKE_STOW}" -R -v make-latest

    # Print information about new binary
    move_to_front_of_path "${MAKE_STOW%/*}"/bin
    command -v make
    make --version
); }

# Build/update ninja
function bninja() { (
    header "Building ninja"

    # Variables for function
    NINJA_REPO=ninja-build/ninja
    [[ -z ${NINJA_VERSION} ]] && NINJA_VERSION=$(glr "${NINJA_REPO}")
    NINJA_SRC=${SRC_FOLDER:?}/ninja/ninja-${NINJA_VERSION//v/}

    # Download source
    mkdir -p "${NINJA_SRC%/*}"
    [[ -d ${NINJA_SRC} ]] || curl -LSs https://github.com/"${NINJA_REPO}"/archive/"${NINJA_VERSION}".tar.gz | tar -C "${NINJA_SRC%/*}" -xzf -

    # Build software
    cd "${NINJA_SRC}" || die "Downloading or extracting ninja failed"
    python3 ./configure.py --bootstrap
    if [[ -f ninja ]]; then
        NINJA_BIN=${PREFIX:-${USR_FOLDER:?}}/bin
        install -Dm755 ninja "${NINJA_BIN}"/ninja

        move_to_front_of_path "${NINJA_BIN}"
        command -v ninja
        ninja --version
    fi
); }

# Build/install PGO'd LLVM
function bpgollvm() { (
    bllvm --lto --pgo
); }

# Build/install exa
function biexa() { (
    EXA_REPO=ogham/exa
    EXA_BASE_URL=https://github.com/${EXA_REPO}
    EXA_VERSION=$(glr ${EXA_REPO})

    if [[ $(uname -m) = "x86_64" ]]; then
        EXA_STOW=${PREFIX:-${USR_FOLDER:?}}/stow
        EXA_BIN=${EXA_STOW}/prebuilts/bin
        EXA_ZIP=exa-linux-x86_64-${EXA_VERSION}.zip

        WORK_DIR=$(mktemp -d)
        cd "${WORK_DIR}" || exit ${?}

        header "Installing exa"
        curl -LSsO "${EXA_BASE_URL}"/releases/download/"${EXA_VERSION}"/"${EXA_ZIP}" || die "Error downloading ${EXA_ZIP}"
        unzip "${EXA_ZIP}" || exit ${?}
        install -Dm755 bin/exa "${EXA_BIN}"/exa
        [[ -n ${ZSH_NAME} ]] && install -Dm644 completions/exa.zsh "${HOME}"/.zfunctions/_exa

        stow -d "${EXA_STOW}" -R -v prebuilts

        move_to_front_of_path "${EXA_STOW%/*}"/bin

        cd && rm -rf "${WORK_DIR}"
    else
        header "Building exa"

        # Install rust
        [[ -d ${HOME}/.cargo/bin ]] || irust
        move_to_front_of_path "${HOME}/.cargo/bin"

        # Variables for function
        EXA_SRC=${SRC_FOLDER:?}/exa/exa-${EXA_VERSION//v/}

        # Download source
        mkdir -p "${EXA_SRC%/*}"
        [[ -d ${EXA_SRC} ]] || curl -LSs "${EXA_BASE_URL}"/archive/"${EXA_VERSION}".tar.gz | tar -C "${EXA_SRC%/*}" -xzf -

        # Build software
        cd "${EXA_SRC}" || die "Error downloading/extracting exa source"
        cargo build --release --locked || die "cargo build failed"
        cargo install --force --path . || die "cargo install failed"
    fi

    # Print information about new binary
    command -v exa
    exa --version
); }

# Build/install ripgrep
function birg() { (
    RG_REPO=BurntSushi/ripgrep
    [[ -z ${RG_VERSION} ]] && RG_VERSION=$(glr "${RG_REPO}")
    BASE_URL=https://github.com/${RG_REPO}

    if [[ $(uname -m) = "x86_64" ]]; then
        header "Installing ripgrep"

        RG_STOW=${PREFIX:-${USR_FOLDER:?}}/stow
        RG_BIN=${RG_STOW}/prebuilts/bin
        RG_TAR=ripgrep-${RG_VERSION}-x86_64-unknown-linux-musl.tar.gz

        WORK_DIR=$(mktemp -d)
        cd "${WORK_DIR}" || exit ${?}

        curl -LSs "${BASE_URL}"/releases/download/"${RG_VERSION}"/"${RG_TAR}" | tar -xzf - || die "Error downloading ${RG_TAR}"
        cd "${RG_TAR%.tar.gz}" || exit ${?}
        install -Dm755 rg "${RG_BIN}"/rg

        stow -d "${RG_STOW}" -R -v prebuilts

        move_to_front_of_path "${RG_STOW%/*}"/bin
    else
        header "Building ripgrep"

        # Install rust if necessary
        [[ -d ${HOME}/.cargo/bin ]] || irust
        move_to_front_of_path "${HOME}/.cargo/bin"

        # Download source
        RG_SRC=${SRC_FOLDER:?}/ripgrep/ripgrep-${RG_VERSION}
        mkdir -p "${RG_SRC%/*}"
        [[ -d ${RG_SRC} ]] || curl -LSs "${BASE_URL}"/archive/"${RG_VERSION}".tar.gz | tar -C "${RG_SRC%/*}" -xzf -

        # Build and install software
        cd "${RG_SRC}" || die "Error downloading ripgrep source"
        cargo build --release --locked --features 'pcre2' || die "cargo build failed"
        cargo install --force --path . || die "cargo install failed"
    fi
    [[ -n ${ZSH_NAME} ]] && install -Dm644 complete/_rg "${HOME}"/.zfunctions/_rg
    [[ -n ${WORK_DIR} ]] && cd && rm -rf "${WORK_DIR}"

    command -v rg
    rg --version
); }

# Build/install sharkdp binaries
function bisharkdp() { (
    BINARIES=()
    while ((${#})); do
        case ${1} in
            all) BINARIES=(bat diskus fd hyperfine) ;;
            bat | diskus | fd | hyperfine) BINARIES+=("${1}") ;;
            *) die "Unsupported binary detected" ;;
        esac
        shift
    done

    WORK_DIR=$(mktemp -d)

    for BINARY in "${BINARIES[@]}"; do (
        BINARY_REPO=sharkdp/${BINARY}
        URL_BASE=https://github.com/${BINARY_REPO}
        [[ -z ${BIN_VERSION} ]] && BIN_VERSION=$(glr "${BINARY_REPO}")

        if [[ $(uname -m) = "x86_64" ]] && command -v dpkg &>/dev/null; then
            header "Installing ${BINARY}"

            BINARY_STOW=${PREFIX:-${USR_FOLDER:?}}/stow
            BINARY_BIN=${BINARY_STOW}/prebuilts/bin
            BINARY_TAR=${BINARY}-${BIN_VERSION}-x86_64-unknown-linux-gnu.tar.gz

            cd "${WORK_DIR}" || exit ${?}
            curl -LSs "${URL_BASE}"/releases/download/"${BIN_VERSION}"/"${BINARY_TAR}" | tar -xzf - || die "Error downloading ${BINARY_TAR}"
            cd "${BINARY_TAR%.tar.gz}" || exit ${?}
            install -Dm755 "${BINARY}" "${BINARY_BIN}"/"${BINARY}"
            if [[ -n ${ZSH_NAME} ]]; then
                case ${BINARY} in
                    bat) BINARY_AUTOCOMP=${BINARY}.zsh ;;
                    fd | hyperfine) BINARY_AUTOCOMP=_${BINARY} ;;
                esac
                [[ -n ${BINARY_AUTOCOMP} ]] && install -Dm644 autocomplete/"${BINARY_AUTOCOMP}" "${HOME}"/.zfunctions/_"${BINARY}"
            fi

            stow -d "${BINARY_STOW}" -R -v prebuilts

            move_to_front_of_path "${BINARY_STOW%/*}"/bin
        else
            header "Building ${BINARY}"

            # Install rust if necessary
            [[ -d ${HOME}/.cargo/bin ]] || irust
            move_to_front_of_path "${HOME}/.cargo/bin"

            # Download source
            BINARY_SRC=${SRC_FOLDER}/${BINARY}/${BINARY}-${BIN_VERSION//v/}
            mkdir -p "${BINARY_SRC%/*}"
            [[ -d ${BINARY_SRC} ]] || curl -LSs "${URL_BASE}"/archive/"${BIN_VERSION}".tar.gz | tar -C "${BINARY_SRC%/*}" -xzf -

            # Build software
            cd "${BINARY_SRC}" || die "Error downloading ${BINARY} source"
            cargo build --release --locked || die "cargo build failed"
            cargo install --force --path . || die "cargo install failed"

            # Install zsh completions
            if [[ -n ${ZSH_NAME} ]]; then
                case ${BINARY} in
                    fd) install -Dm644 target/release/build/fd-find-*/out/_fd "${HOME}"/.zfunctions/_fd ;;
                esac
            fi
            move_to_front_of_path "${HOME}/.cargo/bin"
        fi

        # Print information about new binary
        command -v "${BINARY}"
        "${BINARY}" --version
    ); done

    rm -rf "${WORK_DIR}"
); }

# Build/update tmux
function btmux() { (
    header "Building tmux"

    # Variables for function
    TMUX_REPO=tmux/tmux
    [[ -z ${TMUX_VERSION} ]] && TMUX_VERSION=$(glr "${TMUX_REPO}")
    TMUX_SRC=${SRC_FOLDER:?}/tmux/tmux-${TMUX_VERSION}
    TMUX_STOW=${PREFIX:-${USR_FOLDER:?}}/stow
    TMUX_PREFIX=${TMUX_STOW}/packages/tmux/$(date +%F-%H-%M-%S)-${TMUX_VERSION}

    # Download source
    mkdir -p "${TMUX_SRC%/*}"
    [[ -d ${TMUX_SRC} ]] || curl -LSs https://github.com/"${TMUX_REPO}"/releases/download/"${TMUX_VERSION}"/"${TMUX_SRC##*/}".tar.gz | tar -C "${TMUX_SRC%/*}" -xzf -

    # Build software
    cd "${TMUX_SRC}" || die "Downloading or extracting tmux failed"
    ./configure --prefix="${TMUX_PREFIX}"
    make "${JOBS_FLAG}" install || die "make install failed"

    # Update symlink and stow new package
    ln -fnrsv "${TMUX_PREFIX}" "${TMUX_STOW}"/tmux-latest
    stow -d "${TMUX_STOW}" -R -v tmux-latest

    # Print information about new binary
    move_to_front_of_path "${TMUX_STOW%/*}"/bin
    command -v tmux
    tmux -V
); }

# Build/update zsh
function bzsh() { (
    header "Building zsh"

    [[ -z ${BZSH_VERSION} ]] && BZSH_VERSION=5.8
    ZSH_SRC=${SRC_FOLDER:?}/zsh/zsh-${BZSH_VERSION}
    ZSH_STOW=${PREFIX:-${USR_FOLDER:?}}/stow
    ZSH_PREFIX=${ZSH_STOW}/packages/zsh/$(date +%F-%H-%M-%S)-${BZSH_VERSION}

    # Download source
    mkdir -p "${ZSH_SRC%/*}"
    [[ -d ${ZSH_SRC} ]] || curl -LSs https://www.zsh.org/pub/"${ZSH_SRC##*/}".tar.xz | tar -C "${ZSH_SRC%/*}" -xvJf -

    # Build software
    cd "${ZSH_SRC}" || die "Downloading or extracting zsh failed"
    ./configure --prefix="${ZSH_PREFIX}"
    make "${JOBS_FLAG}" install || die "make install failed"

    # Update symlink and stow new package
    ln -fnrsv "${ZSH_PREFIX}" "${ZSH_STOW}"/zsh-latest
    stow -d "${ZSH_STOW}" -R -v zsh-latest

    # Change shell
    ZSH_BIN=${ZSH_STOW%/*}/bin/zsh
    # grep -q "${ZSH_BIN}" /etc/shells || echo "${ZSH_BIN}" | sudo tee -a /etc/shells
    # [[ ${SHELL} != "${ZSH_BIN}" ]] && sudo chsh -s "${ZSH_BIN}" "$(whoami)"

    move_to_front_of_path "${ZSH_BIN%/*}"
    command -v zsh
    zsh --version
); }

# Get LLVM_ALL_PROJECTS value minus a couple of problematic projects
function llvm_all_projects() { (
    # llgo is/was broken (https://llvm.org/pr42548)
    # debuginfo-tests breaks frequently due to mlir changes (https://reviews.llvm.org/D98613)
    grep -F "set(LLVM_ALL_PROJECTS " "${1:?}"/llvm/CMakeLists.txt | cut -d \" -f 2 | sed -e 's/debuginfo-tests//' -e 's/llgo//' -e 's/;;/;/g' -e 's/;$//' -e 's/^;//'
); }

#######################
#  INSTALL PREBUILTS  #
#######################

# Install Android tools
function iandroidtools() { (
    header "Installing Android tools"

    ANDROID_STOW=${PREFIX:-${USR_FOLDER:?}}/stow
    ANDROID_BIN=${ANDROID_STOW}/prebuilts/bin

    mkdir -p "${ANDROID_BIN}"
    curl -LSso "${ANDROID_BIN}"/repo https://storage.googleapis.com/git-repo-downloads/repo
    chmod a+x "${ANDROID_BIN}"/repo

    MKDTIMG_FOLDER=$(mktemp -d)
    curl -LSs https://android.googlesource.com/platform/prebuilts/misc/+archive/master/linux-x86/libufdt.tar.gz | tar -C "${MKDTIMG_FOLDER}" -xzf -
    cp "${MKDTIMG_FOLDER}"/mkdtimg "${ANDROID_BIN}"
    rm -rf "${MKDTIMG_FOLDER}"

    stow -d "${ANDROID_STOW}" -R -v prebuilts
); }

# Install arcanist
function iarc() { (
    header "Installing arcanist"

    ARC_FOLDER=${SRC_FOLDER:?}/arcanist
    mkdir -p "${ARC_FOLDER}"
    for REPO in arcanist libphutil; do
        REPO_FOLDER=${ARC_FOLDER}/${REPO}
        [[ -d ${REPO_FOLDER} ]] || git clone https://github.com/phacility/${REPO}.git "${REPO_FOLDER}"
        git -C "${REPO_FOLDER}" pull --rebase --quiet
    done

    ARC_STOW=${PREFIX:-${USR_FOLDER:?}}/stow
    ARC_BIN=${ARC_STOW}/prebuilts/bin
    mkdir -p "${ARC_BIN}"
    ln -fs "${ARC_FOLDER}"/arcanist/bin/arc "${ARC_BIN}"/arc
    stow -d "${ARC_STOW}" -R -v prebuilts
); }

# Install hugo
function ihugo() { (
    header "Installing hugo"
    HUGO_REPO=gohugoio/hugo
    HUGO_VERSION=$(glr ${HUGO_REPO})
    SUFFIX=64bit
    HUGO_URL=https://github.com/${HUGO_REPO}/releases/download/${HUGO_VERSION}/hugo_extended_${HUGO_VERSION//v/}_Linux-${SUFFIX}
    if command -v dpkg &>/dev/null; then
        curl -LSso "${TMP_DEB:=$(mktemp --suffix=.deb)}" "${HUGO_URL}".deb
        sudo dpkg -i "${TMP_DEB}"
        rm -rf "${TMP_DEB}"
    else
        WORK_DIR=$(mktemp -d)
        curl -LSs "${HUGO_URL}".tar.gz | tar -C "${WORK_DIR}" -xzf -
        HUGO_STOW=${PREFIX:-${USR_FOLDER:?}}/stow
        HUGO_BIN=${HUGO_STOW}/prebuilts/bin/hugo
        install -Dm755 "${WORK_DIR}"/"${HUGO_BIN##*/}" "${HUGO_BIN}"
        stow -d "${HUGO_STOW}" -R -v prebuilts
        rm -rf "${WORK_DIR}"
    fi
); }

# Install hub
function ihub() { (
    header "Installing hub"
    HUB_REPO=github/hub
    [[ -z ${HUB_VERSION} ]] && HUB_VERSION=$(glr ${HUB_REPO})
    case "$(uname -m)" in
        armv7l) ARCH=arm ;;
        aarch64)
            # The Raspberry Pi might be running a 64-bit kernel but 32-bit OS
            if command -v dpkg &>/dev/null; then
                case "$(dpkg --print-architecture)" in
                    armhf) ARCH=arm ;;
                    *) ARCH=arm64 ;;
                esac
            else
                ARCH=arm64
            fi
            ;;
        x86_64) ARCH=amd64 ;;
        *) die "Architecture not supported" ;;
    esac
    HUB_TUPLE="hub-linux-${ARCH}-${HUB_VERSION/v/}"
    cd "$(mktemp -d)" || die "Error moving into temporary directory!"
    curl -LSsO https://github.com/${HUB_REPO}/releases/download/"${HUB_VERSION}"/"${HUB_TUPLE}".tgz || die "Error downloading hub!"
    tar -xf "${HUB_TUPLE}".tgz || die "Error extracting hub!"
    HUB_STOW=${PREFIX:-${USR_FOLDER:?}}/stow
    prefix="${HUB_STOW}"/prebuilts ./"${HUB_TUPLE}"/install || die "Error installing hub!"
    if [[ -n ${ZSH_NAME} ]]; then
        mkdir -p "${HOME}"/.zfunctions
        curl -LSso "${HOME}"/.zfunctions/_hub https://github.com/${HUB_REPO}/raw/"${HUB_VERSION}"/etc/hub.zsh_completion
    fi
    stow -d "${HUB_STOW}" -R -v prebuilts
    rm -rf "${PWD}"
); }

# Install shellcheck
function ishellcheck() { (
    header "Installing shellcheck"
    SHCHK_REPO=koalaman/shellcheck
    [[ -z ${SHELLCHECK_VERSION} ]] && SHELLCHECK_VERSION=$(glr "${SHCHK_REPO}")
    SHCHK_FOLDER=$(mktemp -d)/shellcheck-v"${SHELLCHECK_VERSION//v/}"
    curl -LSs https://github.com/"${SHCHK_REPO}"/releases/download/"${SHELLCHECK_VERSION}"/"${SHCHK_FOLDER##*/}".linux.x86_64.tar.xz | tar -C "${SHCHK_FOLDER%/*}" -xJf - || exit ${?}
    SHCHK_STOW=${PREFIX:-${USR_FOLDER:?}}/stow
    install -Dm755 "${SHCHK_FOLDER}"/shellcheck "${SHCHK_STOW}"/prebuilts/bin/shellcheck || exit ${?}
    stow -d "${SHCHK_STOW}" -R -v prebuilts
    rm -rf "${SHCHK_FOLDER%/*}"
); }

# Install shfmt
function ishfmt() { (
    header "Installing shfmt"
    SHFMT_REPO=mvdan/sh
    [[ -z ${SHFMT_VERSION} ]] && SHFMT_VERSION=$(glr ${SHFMT_REPO})
    SHFMT_VERSION=v${SHFMT_VERSION//v/}

    SHFMT_STOW=${PREFIX:-${USR_FOLDER:?}}/stow
    SHFMT_BIN=${SHFMT_STOW}/prebuilts/bin/shfmt
    mkdir -p "${SHFMT_BIN%/*}"
    rm -rf "${SHFMT_BIN}"
    curl -LSso "${SHFMT_BIN}" https://github.com/${SHFMT_REPO}/releases/download/"${SHFMT_VERSION}"/shfmt_"${SHFMT_VERSION}"_linux_amd64 || die "Error downloading/installing shfmt"
    chmod +x "${SHFMT_BIN}"
    stow -d "${SHFMT_STOW}" -R -v prebuilts
); }

function ituxmake() { (
    TUXMAKE_SRC=${SRC_FOLDER:?}/tuxmake
    mkdir -p "${TUXMAKE_SRC%/*}"

    [[ -d ${TUXMAKE_SRC} ]] || git clone https://gitlab.com/Linaro/tuxmake.git "${TUXMAKE_SRC}"
    git -C "${TUXMAKE_SRC}" pull --rebase

    TUXMAKE_STOW=${PREFIX:-${USR_FOLDER:?}}/stow
    TUXMAKE_BIN=${TUXMAKE_STOW}/prebuilts/bin
    mkdir -p "${TUXMAKE_BIN}"
    ln -sf "${TUXMAKE_SRC}"/run "${TUXMAKE_BIN}"/tuxmake
    stow -d "${TUXMAKE_STOW}" -R -v prebuilts
); }

function irust() { (
    curl https://sh.rustup.rs -sSf | bash -s -- -y --no-modify-path
); }

# Install/upgrade b4
function ib4() { (
    header "Installing b4"

    B4_SRC=${SRC_FOLDER:?}/b4
    mkdir -p "${B4_SRC%/*}"

    [[ -d ${B4_SRC} ]] || git clone https://git.kernel.org/pub/scm/utils/b4/b4.git/ "${B4_SRC}"
    git -C "${B4_SRC}" pull --rebase

    B4_STOW=${PREFIX:-${USR_FOLDER:?}}/stow
    B4_BIN=${B4_STOW}/prebuilts/bin
    mkdir -p "${B4_BIN}"
    ln -sf "${B4_SRC}"/b4.sh "${B4_BIN}"/b4
    python3 -m pip install --requirement "${B4_SRC}"/requirements.txt --upgrade --user
    stow -d "${B4_STOW}" -R -v prebuilts
); }

# Main install function
function updbin() { (
    # git comes first in case we are rebuilding ~/usr from scratch
    # 'alias git=hub' can cause issues
    bgit || exit ${?}

    # Everything else is alphabetical
    bccache || exit ${?}
    bcmake || exit ${?}
    bcvise || exit ${?}
    bmake || exit ${?}
    bninja || exit ${?}
    biexa || exit ${?}
    birg || exit ${?}
    bisharkdp all || exit ${?}
    btmux || exit ${?}
    bzsh || exit ${?}
    ishellcheck || exit ${?}
    ishfmt || exit ${?}
); }
# vi: filetype=zsh
