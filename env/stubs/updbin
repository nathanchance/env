#!/usr/bin/env bash
# SPDX-License-Identifier: GPL-3.0-or-later
#
# Shebang is purely for syntax highlighting and shellcheck auditing; script must be sourced to be useful
#
# Copyright (C) 2019-2021 Nathan Chancellor
#
# Functions to build the latest versions of certain pieces of software

#######################
#  BUILD FROM SOURCE  #
#######################

# Build/update ccache
function bccache() { (
    header "Building ccache"

    # Variables for function
    CCACHE_REPO=ccache/ccache
    [[ -z ${CCACHE_VERSION} ]] && CCACHE_VERSION=$(glr "${CCACHE_REPO}")
    CCACHE_SRC=${SRC_FOLDER:?}/ccache/ccache-${CCACHE_VERSION//v/}
    CCACHE_STOW=${PREFIX:-${USR_FOLDER:?}}/stow
    CCACHE_PREFIX=${CCACHE_STOW}/packages/ccache/${CCACHE_VERSION//v/}-$(date +%F-%H-%M-%S)

    # Download source
    mkdir -p "${CCACHE_SRC%/*}"
    [[ -d ${CCACHE_SRC} ]] || curl -LSs https://github.com/"${CCACHE_REPO}"/releases/download/"${CCACHE_VERSION}"/"${CCACHE_SRC##*/}".tar.gz | tar -C "${CCACHE_SRC%/*}" -xzf -

    # Prepare build folder
    CCACHE_BUILD=${CCACHE_SRC}/build
    rm -rf "${CCACHE_BUILD}"
    mkdir -p "${CCACHE_BUILD}"
    cd "${CCACHE_BUILD}" || die "Could not create build folder"

    # Build software
    mkdir -p "${CCACHE_PREFIX%/*}"
    cmake \
        -DCMAKE_BUILD_TYPE=Release \
        -DCMAKE_INSTALL_PREFIX="${CCACHE_PREFIX}" \
        -DZSTD_FROM_INTERNET=ON .. || die "cmake configuration failed"
    make "${JOBS_FLAG}" install || die "make install failed"

    # Update symlink and stow new package
    ln -fnrsv "${CCACHE_PREFIX}" "${CCACHE_STOW}"/ccache-latest
    stow -d "${CCACHE_STOW}" -R -v ccache-latest

    # Print information about new binary
    move_to_front_of_path "${CCACHE_STOW%/*}"/bin
    command -v ccache
    ccache --version
); }

# Build/update cmake
function bcmake() { (
    header "Building cmake"

    # Variables for function
    CMAKE_REPO=Kitware/CMake
    [[ -z ${CMAKE_VERSION} ]] && CMAKE_VERSION=$(glr "${CMAKE_REPO}")
    CMAKE_SRC=${SRC_FOLDER:?}/cmake/cmake-${CMAKE_VERSION//v/}
    CMAKE_STOW=${PREFIX:-${USR_FOLDER:?}}/stow
    CMAKE_PREFIX=${CMAKE_STOW}/packages/cmake/${CMAKE_VERSION//v/}-$(date +%F-%H-%M-%S)

    # Download source
    mkdir -p "${CMAKE_SRC%/*}"
    [[ -d ${CMAKE_SRC} ]] || curl -LSs https://github.com/"${CMAKE_REPO}"/releases/download/"${CMAKE_VERSION}"/"${CMAKE_SRC##*/}".tar.gz | tar -C "${CMAKE_SRC%/*}" -xzf -

    # Build software
    cd "${CMAKE_SRC}" || die "Downloading or extracting cmake failed"
    ./bootstrap \
        --parallel="$(nproc)" \
        --prefix="${CMAKE_PREFIX}"
    make "${JOBS_FLAG}" install || die "make failed"

    # Update symlink and stow new package
    ln -fnrsv "${CMAKE_PREFIX}" "${CMAKE_STOW}"/cmake-latest
    stow -d "${CMAKE_STOW}" -R -v cmake-latest

    # Print information about new binary
    move_to_front_of_path "${CMAKE_STOW%/*}"/bin
    command -v cmake
    cmake --version
); }

# Build/update cvise
function bcvise() { (
    # Find distribution version of LLVM (special handling for Debian / Ubuntu)
    for LLVM_VER in $(seq 20 -1 7); do
        LLVM_DIR=/usr/lib/llvm-${LLVM_VER}
        if [[ -d ${LLVM_DIR} ]]; then
            CMAKE_PREFIX_PATH=${LLVM_DIR}
            break
        fi
    done
    [[ -z ${CMAKE_PREFIX_PATH} ]] && CMAKE_PREFIX_PATH=/usr

    if [[ $("${SCRIPTS_FOLDER}"/external/cc-version.sh "${CMAKE_PREFIX_PATH}"/bin/clang | awk '{print $2}') -lt 90000 ]]; then
        header "Skipping cvise due to older clang"
        exit 0
    fi

    header "Building cvise"

    # Variables for function
    CVISE_REPO=marxin/cvise
    [[ -z ${CVISE_VERSION} ]] && CVISE_VERSION=$(glr ${CVISE_REPO})
    CVISE_SRC=${SRC_FOLDER:?}/cvise/cvise-${CVISE_VERSION//v/}
    CVISE_STOW=${PREFIX:-${USR_FOLDER:?}}/stow
    CVISE_PREFIX=${CVISE_STOW}/packages/cvise/${CVISE_VERSION//v/}-$(date +%F-%H-%M-%S)

    # Download source
    mkdir -p "${CVISE_SRC%/*}"
    [[ -d ${CVISE_SRC} ]] || curl -LSs https://github.com/${CVISE_REPO}/archive/v"${CVISE_VERSION//v/}".tar.gz | tar -C "${CVISE_SRC%/*}" -xzf -

    # Download and install dependencies
    python3 -m pip install --upgrade --user pebble pytest
    path_push "${HOME}"/.local/bin

    # Prepare build folder
    CVISE_BLD=${CVISE_SRC}/build
    rm -rf "${CVISE_BLD}"
    mkdir -p "${CVISE_BLD}"
    cd "${CVISE_BLD}" || die "Error creating build folder"

    # Build software
    cmake \
        -DCMAKE_C_COMPILER="$(command -v clang || command -v gcc)" \
        -DCMAKE_CXX_COMPILER="$(command -v clang++ || command -v g++)" \
        -DCMAKE_INSTALL_PREFIX="${CVISE_PREFIX}" \
        -DCMAKE_PREFIX_PATH=${CMAKE_PREFIX_PATH} \
        -DPYTHON_EXECUTABLE="$(command -v python3)" \
        .. || die "Error configuring cvise"
    make "${JOBS_FLAG}" install || die "Error building cvise"

    # Update symlink and stow new package
    ln -fnrsv "${CVISE_PREFIX}" "${CVISE_STOW}"/cvise-latest
    stow -d "${CVISE_STOW}" -R -v cvise-latest

    # Print information about new binary
    move_to_front_of_path "${CVISE_STOW%/*}"/bin
    command -v cvise
    cvise --version
); }

# Build/update dtc
function bdtc() { (
    header "Building dtc"

    # Download source
    DTC_FOLDER=${SRC_FOLDER:?}/dtc
    if [[ ! -d ${DTC_FOLDER} ]]; then
        mkdir -p "${DTC_FOLDER%/*}"
        git clone https://git.kernel.org/pub/scm/utils/dtc/dtc.git "${DTC_FOLDER}"
    fi
    cd "${DTC_FOLDER}" || die "Couldn't move into ${DTC_FOLDER}"

    # Clean up from previous compiles and update repo
    git clean -fxdq
    git fetch
    [[ -z ${DTC_VERSION} ]] && DTC_VERSION=$(git describe --tags "$(git rev-list --tags --max-count=1)")
    git checkout v"${DTC_VERSION//v/}"

    # Path variables
    DTC_STOW=${PREFIX:-${USR_FOLDER:?}}/stow
    DTC_PREFIX=${DTC_STOW}/packages/dtc/${DTC_VERSION//v/}-$(date +%F-%H-%M-%S)

    # Build software
    mkdir -p "${DTC_PREFIX%/*}"
    make "${JOBS_FLAG}" NO_PYTHON=1 PREFIX="${DTC_PREFIX}" install

    # Update symlink and stow new package
    ln -fnrsv "${DTC_PREFIX}" "${DTC_STOW}"/dtc-latest
    stow -d "${DTC_STOW}" -R -v dtc-latest

    # Print information about new binary
    move_to_front_of_path "${DTC_STOW%/*}"/bin
    command -v dtc
    dtc --version
); }

# Build/update git
function bgit() { (
    # Install hub first in case git is an alias to hub
    ihub || exit ${?}

    header "Building git"

    # If we are on x86, we should tune for native
    [[ $(uname -m) =~ x86 ]] && MARCH="-march=native "

    # Variables for function

    # Make variable
    # Taken from https://github.com/archlinux/svntogit-packages/blob/packages/git/trunk/PKGBUILD
    MAKE=(
        make
        "${JOBS_FLAG}"
        CFLAGS="${MARCH}-O2 -pipe -fstack-protector-strong -fno-plt"
        LDFLAGS="-Wl,-O1,--sort-common,--as-needed,-z,relro,-z,now"
        INSTALL_SYMLINKS=1
        NO_PERL_CPAN_FALLBACKS=1
        USE_LIBPCRE2=1
    )

    # Download/update source
    GIT_FOLDER=${SRC_FOLDER:?}/git
    if [[ ! -d ${GIT_FOLDER} ]]; then
        mkdir -p "${GIT_FOLDER%/*}"
        git clone https://git.kernel.org/pub/scm/git/git.git "${GIT_FOLDER}"
    fi
    cd "${GIT_FOLDER}" || die "Couldn't move into ${GIT_FOLDER}"
    git clean -fxdq
    git pull --rebase

    # Path variables
    GIT_STOW=${PREFIX:-${USR_FOLDER:?}}/stow
    GIT_PREFIX=${GIT_STOW}/packages/git/$(git show -s --format=%H)-$(date +%F-%H-%M-%S)

    # Build and install software + completions
    "${MAKE[@]}" prefix="${GIT_PREFIX}" all install || die "git build/install failed"
    if [[ -n ${ZSH_NAME} ]]; then
        install -Dm644 "${GIT_FOLDER}"/contrib/completion/git-completion.bash "${GIT_PREFIX}"/share/bash-completion/completions/git
        install -Dm644 "${GIT_FOLDER}"/contrib/completion/git-completion.zsh "${HOME}"/.zfunctions/_git
    fi

    # Update symlink and stow new package
    ln -fnrsv "${GIT_PREFIX}" "${GIT_STOW}"/git-latest
    stow -d "${GIT_STOW}" -R -v git-latest

    # Print information about new binary
    move_to_front_of_path "${GIT_STOW%/*}"/bin
    command -v git
    git --version
); }

# Build a "regular" LLVM toolchain or a bootstrap compiler
function bllvm() { (
    set -u

    LLVM_SRC=${SRC_FOLDER:-${HOME}/src}/llvm-project
    if [[ ! -d ${LLVM_SRC} ]]; then
        header "Cloning LLVM"
        mkdir -p "${LLVM_SRC%/*}"
        git clone https://github.com/llvm/llvm-project "${LLVM_SRC}" || exit ${?}
    fi

    LLVM_BLD=${LLVM_SRC}/build/stage1
    rm -rf "${LLVM_BLD%/*}"
    mkdir -p "${LLVM_BLD}"
    cd "${LLVM_BLD}" || exit ${?}

    while ((${#})); do
        case ${1} in
            -b | --bootstrap) BOOTSTRAP=true ;;
            -i | --install) INSTALL=true ;;
        esac
        shift
    done

    CMAKE=(
        cmake
        -G Ninja
        -Wno-dev
        "-DCLANG_DEFAULT_LINKER=lld"
        "-DCLANG_VENDOR=$(uname -n)"
        "-DCMAKE_AR=$(command -v llvm-ar)"
        "-DCMAKE_BUILD_TYPE=Release"
        "-DCMAKE_C_COMPILER=$(command -v clang)"
        "-DCMAKE_CXX_COMPILER=$(command -v clang++)"
        "-DCMAKE_LINKER=$(command -v ld.lld)"
        "-DCMAKE_RANLIB=$(command -v llvm-ranlib)"
        "-DLLVM_CCACHE_BUILD=ON"
        "-DLLVM_ENABLE_PROJECTS=$(llvm_all_projects "${LLVM_SRC}")"
        "-DLLVM_ENABLE_WARNINGS=OFF"
        "-DLLVM_USE_LINKER=lld"
    )

    if ${BOOTSTRAP:=false}; then
        CMAKE=(
            "${CMAKE[@]}"
            "-DCLANG_PLUGIN_SUPPORT=OFF"
            "-DCOMPILER_RT_BUILD_SANITIZERS=OFF"
            "-DLLVM_ENABLE_BACKTRACES=OFF"
            "-DLLVM_INCLUDE_DOCS=OFF"
            "-DLLVM_INCLUDE_EXAMPLES=OFF"
            "-DLLVM_INCLUDE_TESTS=OFF"
            "-DLLVM_TARGETS_TO_BUILD=host"
        )
    fi

    if ${INSTALL:=false}; then
        CMAKE=("${CMAKE[@]}" "-DCMAKE_INSTALL_PREFIX=${PREFIX:-${USR_FOLDER:?}}")
    fi

    header "Configuring LLVM"
    echo "$ ${CMAKE[*]}"
    echo
    "${CMAKE[@]}" "${LLVM_SRC}"/llvm >/dev/null || exit ${?}

    header "Building LLVM"
    ninja || exit ${?}

    if ! ${BOOTSTRAP}; then
        header "Running LLVM tests"
        ninja check-clang check-lld check-llvm check-llvm-unit || exit ${?}
    fi

    if ${INSTALL}; then
        header "Installing LLVM"
        ninja install || exit ${?}
    fi
); }

# Build/install GNU make
function bmake() { (
    header "Building make"

    # Variables for function
    [[ -z ${MAKE_VERSION} ]] && MAKE_VERSION=4.3
    MAKE_SRC=${SRC_FOLDER:?}/make/make-${MAKE_VERSION}
    MAKE_STOW=${PREFIX:-${USR_FOLDER:?}}/stow
    MAKE_PREFIX=${MAKE_STOW}/packages/make/${MAKE_VERSION}-$(date +%F-%H-%M-%S)

    # Download source
    mkdir -p "${MAKE_SRC%/*}"
    [[ -d ${MAKE_SRC} ]] || curl -LSs http://ftp.gnu.org/gnu/make/"${MAKE_SRC##*/}".tar.gz | tar -C "${MAKE_SRC%/*}" -xzf -

    # Build software
    cd "${MAKE_SRC}" || die "Downloading or extracting make failed"
    ./configure --prefix="${MAKE_PREFIX}" || die "Error configuring make"
    make "${JOBS_FLAG}" install || die "Error building make"

    # Update symlink and stow new package
    ln -fnrsv "${MAKE_PREFIX}" "${MAKE_STOW}"/make-latest
    stow -d "${MAKE_STOW}" -R -v make-latest

    # Print information about new binary
    move_to_front_of_path "${MAKE_STOW%/*}"/bin
    command -v make
    make --version
); }

# Build/update ninja
function bninja() { (
    header "Building ninja"

    # Variables for function
    NINJA_REPO=ninja-build/ninja
    [[ -z ${NINJA_VERSION} ]] && NINJA_VERSION=$(glr "${NINJA_REPO}")
    NINJA_SRC=${SRC_FOLDER:?}/ninja/ninja-${NINJA_VERSION//v/}

    # Download source
    mkdir -p "${NINJA_SRC%/*}"
    [[ -d ${NINJA_SRC} ]] || curl -LSs https://github.com/"${NINJA_REPO}"/archive/"${NINJA_VERSION}".tar.gz | tar -C "${NINJA_SRC%/*}" -xzf -

    # Build software
    cd "${NINJA_SRC}" || die "Downloading or extracting ninja failed"
    python3 ./configure.py --bootstrap
    if [[ -f ninja ]]; then
        NINJA_BIN=${PREFIX:-${USR_FOLDER:?}}/bin
        install -Dm755 ninja "${NINJA_BIN}"/ninja

        move_to_front_of_path "${NINJA_BIN}"
        command -v ninja
        ninja --version
    fi
); }

# Build/install PGO'd LLVM
function bpgollvm() { (
    LLVM_SRC=${SRC_FOLDER}/llvm-project
    CMAKE=(
        cmake
        -G Ninja
        -Wno-dev
        "-DCLANG_DEFAULT_LINKER=lld"
        "-DCLANG_VENDOR=$(uname -n)"
        "-DCMAKE_BUILD_TYPE=Release"
        "-DLLVM_ENABLE_PROJECTS=$(llvm_all_projects "${LLVM_SRC}")"
    )
    LLVM_BLD=${LLVM_SRC}/build
    ORIG_PATH=${PATH}
    START=$(date +%s)

    set -eu

    while ((${#})); do
        case ${1} in
            -b | --branch)
                shift
                LLVM_VERSION=${1}
                ;;
            -u | --update) UPDATE=true ;;
        esac
        shift
    done

    if [[ ! -d ${LLVM_SRC} ]]; then
        header "Downloading LLVM"
        mkdir -p "${LLVM_SRC%/*}"
        git clone https://github.com/llvm/llvm-project "${LLVM_SRC}"
    fi

    cd "${LLVM_SRC}"
    git clean -fxdq

    if ${UPDATE:=false}; then
        header "Updating LLVM"
        git reset --hard
        git fetch origin
        git checkout "${LLVM_VERSION:=master}"
        [[ ${LLVM_VERSION} = "master" || ${LLVM_VERSION} =~ release ]] && git pull --rebase
    fi

    # Stage 1: Bootstrap compiler
    (
        header "Building LLVM stage 1"
        mkdir -p "${LLVM_BLD}"/stage1
        cd "${LLVM_BLD}"/stage1 || die "Error creating stage1 build folder"
        LINKER=$(if command -v ld.lld &>/dev/null; then echo lld; else echo gold; fi)
        "${CMAKE[@]}" \
            -DCLANG_PLUGIN_SUPPORT=OFF \
            -DCMAKE_C_COMPILER=clang \
            -DCMAKE_CXX_COMPILER=clang++ \
            -DCOMPILER_RT_BUILD_SANITIZERS=OFF \
            -DLLVM_ENABLE_BACKTRACES=OFF \
            -DLLVM_INCLUDE_DOCS=OFF \
            -DLLVM_INCLUDE_EXAMPLES=OFF \
            -DLLVM_INCLUDE_TESTS=OFF \
            -DLLVM_TARGETS_TO_BUILD=host \
            -DLLVM_USE_LINKER="${LINKER}" \
            "${LLVM_SRC}"/llvm || die "Error configuring stage 1"
        ninja || die "Error building stage 1"
    )

    STAGE_ONE_BIN=${LLVM_BLD}/stage1/bin
    STAGE_ONE_BIN_DEFINES=(
        -DCMAKE_AR="${STAGE_ONE_BIN}"/llvm-ar
        -DCMAKE_C_COMPILER="${STAGE_ONE_BIN}"/clang
        -DCLANG_TABLEGEN="${STAGE_ONE_BIN}"/clang-tblgen
        -DCMAKE_CXX_COMPILER="${STAGE_ONE_BIN}"/clang++
        -DCMAKE_LINKER="${STAGE_ONE_BIN}"/ld.lld
        -DLLVM_USE_LINKER=lld
        -DLLVM_TABLEGEN="${STAGE_ONE_BIN}"/llvm-tblgen
        -DCMAKE_RANLIB="${STAGE_ONE_BIN}"/llvm-ranlib
    )

    # Stage 2a: Instrumented compiler
    export PATH=${STAGE_ONE_BIN:?}:${ORIG_PATH}
    (
        header "Building LLVM stage 2a"
        mkdir -p "${LLVM_BLD}"/stage2a
        cd "${LLVM_BLD}"/stage2a || die "Error creating stage2a build folder"
        "${CMAKE[@]}" \
            "${STAGE_ONE_BIN_DEFINES[@]}" \
            -DLLVM_BUILD_INSTRUMENTED=IR \
            -DLLVM_BUILD_RUNTIME=OFF \
            -DLLVM_INCLUDE_GO_TESTS=OFF \
            "${LLVM_SRC}"/llvm || die "Error configuring stage 2a"
        ninja clang lld check-clang check-llvm || die "Error building or checking stage2a"
    )

    STAGE_TWO_BIN=${LLVM_BLD}/stage2a/bin
    STAGE_TWO_BIN_DEFINES=(
        -DCMAKE_AR="${STAGE_TWO_BIN}"/llvm-ar
        -DCMAKE_C_COMPILER="${STAGE_TWO_BIN}"/clang
        -DCLANG_TABLEGEN="${STAGE_TWO_BIN}"/clang-tblgen
        -DCMAKE_CXX_COMPILER="${STAGE_TWO_BIN}"/clang++
        -DCMAKE_LINKER="${STAGE_TWO_BIN}"/ld.lld
        -DLLVM_USE_LINKER=lld
        -DLLVM_TABLEGEN="${STAGE_TWO_BIN}"/llvm-tblgen
        -DCMAKE_RANLIB="${STAGE_TWO_BIN}"/llvm-ranlib
    )

    # Stage 2b: Build clang with instrumented compiler
    export PATH=${STAGE_TWO_BIN:?}:${ORIG_PATH}
    (
        header "Building LLVM stage 2b"
        mkdir -p "${LLVM_BLD}"/stage2b
        cd "${LLVM_BLD}"/stage2b
        "${CMAKE[@]}" \
            "${STAGE_TWO_BIN_DEFINES[@]}" \
            "${LLVM_SRC}"/llvm || die "Error configuring stage 2b"
        ninja || die "Error building stage 2b"
    )

    # Stage 3: Build final compiler
    : "${PGO_LLVM_PREFIX:=${PREFIX:-${USR_FOLDER:?}}}"
    export PATH=${STAGE_ONE_BIN:?}:${ORIG_PATH}
    (
        header "Building LLVM stage 3"
        mkdir -p "${LLVM_BLD}"/stage3
        cd "${LLVM_BLD}"/stage3 || die "Error creating stage 3 build folder"

        # Merge profile data
        PROFILE_DATA=${LLVM_BLD}/stage3/profdata.prof
        llvm-profdata merge \
            -output="${PROFILE_DATA}" \
            "${LLVM_BLD}"/stage2a/profiles/*.profraw || die "Error merging profile data"

        # Build compiler with that data
        "${CMAKE[@]}" \
            "${STAGE_ONE_BIN_DEFINES[@]}" \
            -DCMAKE_C_FLAGS="-Wno-backend-plugin" \
            -DCMAKE_CXX_FLAGS="-Wno-backend-plugin" \
            -DCMAKE_INSTALL_PREFIX="${PGO_LLVM_PREFIX}" \
            -DLLVM_ENABLE_LTO=Thin \
            -DLLVM_PROFDATA_FILE="${PROFILE_DATA}" \
            "${LLVM_SRC}"/llvm || die "Error configuring stage 3"
        ninja || die "Error building stage 3"
        ninja install || die "Error installing stage 3"
    )

    header "Final LLVM information"

    echo "Total build time: $(format_time "${START}" "$(date +%s)")"

    move_to_front_of_path "${PGO_LLVM_PREFIX}/bin"

    echo
    command -v clang
    clang --version | head -n1

    echo
    command -v ld.lld
    ld.lld --version
); }

# Build/install exa
function biexa() { (
    EXA_REPO=ogham/exa
    EXA_BASE_URL=https://github.com/${EXA_REPO}
    EXA_VERSION=$(glr ${EXA_REPO})

    if [[ $(uname -m) = "x86_64" ]]; then
        EXA_STOW=${PREFIX:-${USR_FOLDER:?}}/stow
        EXA_BIN=${EXA_STOW}/prebuilts/bin
        EXA_ZIP=exa-linux-x86_64-${EXA_VERSION//v/}.zip

        TMP_FOLDER=$(mktemp -d)
        cd "${TMP_FOLDER}" || exit ${?}

        header "Installing exa"
        curl -LSsO "${EXA_BASE_URL}"/releases/download/"${EXA_VERSION}"/"${EXA_ZIP}" || die "Error downloading ${EXA_ZIP}"
        unzip "${EXA_ZIP}"
        install -Dm755 "${TMP_FOLDER}"/exa-linux-x86_64 "${EXA_BIN}"/exa

        stow -d "${EXA_STOW}" -R -v prebuilts

        move_to_front_of_path "${EXA_STOW%/*}"/bin

        cd && rm -rf "${TMP_FOLDER}"
    else
        header "Building exa"

        # Install rust
        [[ -d ${HOME}/.cargo/bin ]] || irust
        move_to_front_of_path "${HOME}/.cargo/bin"

        # Variables for function
        EXA_SRC=${SRC_FOLDER:?}/exa/exa-${EXA_VERSION//v/}

        # Download source
        mkdir -p "${EXA_SRC%/*}"
        [[ -d ${EXA_SRC} ]] || curl -LSs "${EXA_BASE_URL}"/archive/"${EXA_VERSION}".tar.gz | tar -C "${EXA_SRC%/*}" -xzf -

        # Build software
        cd "${EXA_SRC}" || die "Error downloading/extracting exa source"
        cargo build --release --locked || die "cargo build failed"
        cargo install --force --path . || die "cargo install failed"
    fi

    # Print information about new binary
    command -v exa
    exa --version
); }

# Build/install ripgrep
function birg() { (
    RG_REPO=BurntSushi/ripgrep
    [[ -z ${RG_VERSION} ]] && RG_VERSION=$(glr "${RG_REPO}")
    BASE_URL=https://github.com/${RG_REPO}

    if [[ $(uname -m) = "x86_64" ]] && command -v dpkg &>/dev/null; then
        header "Installing ripgrep"

        DEB=ripgrep_${RG_VERSION}_amd64.deb

        TMP_FOLDER=$(mktemp -d)
        cd "${TMP_FOLDER}"

        curl -LSsO "${BASE_URL}"/releases/download/"${RG_VERSION}"/"${DEB}" || die "Error downloading ${DEB}"
        sudo dpkg -i "${DEB}" || die "Error installing ${DEB}"
        cd && rm -rf "${TMP_FOLDER}"
    else
        header "Building ripgrep"

        # Install rust if necessary
        [[ -d ${HOME}/.cargo/bin ]] || irust
        move_to_front_of_path "${HOME}/.cargo/bin"

        # Download source
        RG_SRC=${SRC_FOLDER:?}/ripgrep/ripgrep-${RG_VERSION}
        mkdir -p "${RG_SRC%/*}"
        [[ -d ${RG_SRC} ]] || curl -LSs "${BASE_URL}"/archive/"${RG_VERSION}".tar.gz | tar -C "${RG_SRC%/*}" -xzf -

        # Build and install software
        cd "${RG_SRC}" || die "Error downloading ripgrep source"
        cargo build --release --locked --features 'pcre2' || die "cargo build failed"
        cargo install --force --path . || die "cargo install failed"
        [[ -n ${ZSH_NAME} ]] && install -Dm644 complete/_rg "${HOME}"/.zfunctions/_rg
    fi

    command -v rg
    rg --version
); }

# Build/install sharkdp binaries
function bisharkdp() { (
    BINARIES=()
    while ((${#})); do
        case ${1} in
            all) BINARIES=(bat diskus fd hyperfine) ;;
            bat | diskus | fd | hyperfine) BINARIES+=("${1}") ;;
            *) die "Unsupported binary detected" ;;
        esac
        shift
    done

    TMP_FOLDER=$(mktemp -d)

    for BINARY in "${BINARIES[@]}"; do (
        BINARY_REPO=sharkdp/${BINARY}
        URL_BASE=https://github.com/${BINARY_REPO}
        [[ -z ${BIN_VERSION} ]] && BIN_VERSION=$(glr "${BINARY_REPO}")

        if [[ $(uname -m) = "x86_64" ]] && command -v dpkg &>/dev/null; then
            header "Installing ${BINARY}"

            DEB=${TMP_FOLDER}/${BINARY}_${BIN_VERSION//v/}_amd64.deb
            curl -LSso "${DEB}" "${URL_BASE}"/releases/download/"${BIN_VERSION}"/"${DEB##*/}" || die "Error downloading ${DEB##*/}"
            sudo dpkg -i "${DEB}" || die "Error installing ${DEB##*/}"
        else
            header "Building ${BINARY}"

            # Install rust if necessary
            [[ -d ${HOME}/.cargo/bin ]] || irust
            move_to_front_of_path "${HOME}/.cargo/bin"

            # Download source
            BINARY_SRC=${SRC_FOLDER}/${BINARY}/${BINARY}-${BIN_VERSION//v/}
            mkdir -p "${BINARY_SRC%/*}"
            [[ -d ${BINARY_SRC} ]] || curl -LSs "${URL_BASE}"/archive/"${BIN_VERSION}".tar.gz | tar -C "${BINARY_SRC%/*}" -xzf -

            # Build software
            cd "${BINARY_SRC}" || die "Error downloading ${BINARY} source"
            cargo build --release --locked || die "cargo build failed"
            cargo install --force --path . || die "cargo install failed"

            # Install zsh completions
            if [[ -n ${ZSH_NAME} ]]; then
                case ${BINARY} in
                    fd) install -Dm644 target/release/build/fd-find-*/out/_fd "${HOME}"/.zfunctions/_fd ;;
                esac
            fi
        fi

        # Print information about new binary
        move_to_front_of_path "${HOME}/.cargo/bin"
        command -v "${BINARY}"
        "${BINARY}" --version
    ); done

    rm -rf "${TMP_FOLDER}"
); }

# Build/update tmux
function btmux() { (
    header "Building tmux"

    # Variables for function
    TMUX_REPO=tmux/tmux
    [[ -z ${TMUX_VERSION} ]] && TMUX_VERSION=$(glr "${TMUX_REPO}")
    TMUX_SRC=${SRC_FOLDER:?}/tmux/tmux-${TMUX_VERSION}
    TMUX_STOW=${PREFIX:-${USR_FOLDER:?}}/stow
    TMUX_PREFIX=${TMUX_STOW}/packages/tmux/${TMUX_VERSION}-$(date +%F-%H-%M-%S)

    # Download source
    mkdir -p "${TMUX_SRC%/*}"
    [[ -d ${TMUX_SRC} ]] || curl -LSs https://github.com/"${TMUX_REPO}"/releases/download/"${TMUX_VERSION}"/"${TMUX_SRC##*/}".tar.gz | tar -C "${TMUX_SRC%/*}" -xzf -

    # Build software
    cd "${TMUX_SRC}" || die "Downloading or extracting tmux failed"
    ./configure --prefix="${TMUX_PREFIX}"
    make "${JOBS_FLAG}" install || die "make install failed"

    # Update symlink and stow new package
    ln -fnrsv "${TMUX_PREFIX}" "${TMUX_STOW}"/tmux-latest
    stow -d "${TMUX_STOW}" -R -v tmux-latest

    # Print information about new binary
    move_to_front_of_path "${TMUX_STOW%/*}"/bin
    command -v tmux
    tmux -V
); }

# Build/update zsh
function bzsh() { (
    header "Building zsh"

    [[ -z ${BZSH_VERSION} ]] && BZSH_VERSION=5.8
    ZSH_SRC=${SRC_FOLDER:?}/zsh/zsh-${BZSH_VERSION}
    ZSH_STOW=${PREFIX:-${USR_FOLDER:?}}/stow
    ZSH_PREFIX=${ZSH_STOW}/packages/zsh/${BZSH_VERSION}-$(date +%F-%H-%M-%S)

    # Download source
    mkdir -p "${ZSH_SRC%/*}"
    [[ -d ${ZSH_SRC} ]] || curl -LSs https://www.zsh.org/pub/"${ZSH_SRC##*/}".tar.xz | tar -C "${ZSH_SRC%/*}" -xvJf -

    # Build software
    cd "${ZSH_SRC}" || die "Downloading or extracting zsh failed"
    ./configure --prefix="${ZSH_PREFIX}"
    make "${JOBS_FLAG}" install || die "make install failed"

    # Update symlink and stow new package
    ln -fnrsv "${ZSH_PREFIX}" "${ZSH_STOW}"/zsh-latest
    stow -d "${ZSH_STOW}" -R -v zsh-latest

    # Change shell
    ZSH_BIN=${ZSH_STOW%/*}/bin/zsh
    # grep -q "${ZSH_BIN}" /etc/shells || echo "${ZSH_BIN}" | sudo tee -a /etc/shells
    # [[ ${SHELL} != "${ZSH_BIN}" ]] && sudo chsh -s "${ZSH_BIN}" "$(whoami)"

    move_to_front_of_path "${ZSH_BIN%/*}"
    command -v zsh
    zsh --version
); }

# Get LLVM_ALL_PROJECTS value minus a couple of problematic projects
function llvm_all_projects() { (
    # llgo is/was broken (https://llvm.org/pr42548)
    # debuginfo-tests breaks frequently due to mlir changes (https://reviews.llvm.org/D98613)
    grep -F "set(LLVM_ALL_PROJECTS " "${1:?}"/llvm/CMakeLists.txt | cut -d \" -f 2 | sed -e 's/debuginfo-tests//' -e 's/llgo//' -e 's/;;/;/g' -e 's/;$//' -e 's/^;//'
); }

#######################
#  INSTALL PREBUILTS  #
#######################

# Install Android tools
function iandroidtools() { (
    header "Installing Android tools"

    ANDROID_STOW=${PREFIX:-${USR_FOLDER:?}}/stow
    ANDROID_BIN=${ANDROID_STOW}/prebuilts/bin

    mkdir -p "${ANDROID_BIN}"
    curl -LSso "${ANDROID_BIN}"/repo https://storage.googleapis.com/git-repo-downloads/repo
    chmod a+x "${ANDROID_BIN}"/repo

    MKDTIMG_FOLDER=$(mktemp -d)
    curl -LSs https://android.googlesource.com/platform/prebuilts/misc/+archive/master/linux-x86/libufdt.tar.gz | tar -C "${MKDTIMG_FOLDER}" -xzf -
    cp "${MKDTIMG_FOLDER}"/mkdtimg "${ANDROID_BIN}"
    rm -rf "${MKDTIMG_FOLDER}"

    stow -d "${ANDROID_STOW}" -R -v prebuilts
); }

# Install arcanist
function iarc() { (
    header "Installing arcanist"

    ARC_FOLDER=${SRC_FOLDER:?}/arcanist
    mkdir -p "${ARC_FOLDER}"
    for REPO in arcanist libphutil; do
        REPO_FOLDER=${ARC_FOLDER}/${REPO}
        [[ -d ${REPO_FOLDER} ]] || git clone https://github.com/phacility/${REPO}.git "${REPO_FOLDER}"
        git -C "${REPO_FOLDER}" pull --rebase --quiet
    done

    ARC_STOW=${PREFIX:-${USR_FOLDER:?}}/stow
    ARC_BIN=${ARC_STOW}/prebuilts/bin
    mkdir -p "${ARC_BIN}"
    ln -fs "${ARC_FOLDER}"/arcanist/bin/arc "${ARC_BIN}"/arc
    stow -d "${ARC_STOW}" -R -v prebuilts
); }

# Install hugo
function ihugo() { (
    header "Installing hugo"
    HUGO_REPO=gohugoio/hugo
    HUGO_VERSION=$(glr ${HUGO_REPO})
    SUFFIX=64bit
    HUGO_URL=https://github.com/${HUGO_REPO}/releases/download/${HUGO_VERSION}/hugo_extended_${HUGO_VERSION//v/}_Linux-${SUFFIX}
    if command -v dpkg &>/dev/null; then
        curl -LSso "${TMP_DEB:=$(mktemp --suffix=.deb)}" "${HUGO_URL}".deb
        sudo dpkg -i "${TMP_DEB}"
        rm -rf "${TMP_DEB}"
    else
        TMP_FOLDER=$(mktemp -d)
        curl -LSs "${HUGO_URL}".tar.gz | tar -C "${TMP_FOLDER}" -xzf -
        HUGO_STOW=${PREFIX:-${USR_FOLDER:?}}/stow
        HUGO_BIN=${HUGO_STOW}/prebuilts/bin/hugo
        install -Dm755 "${TMP_FOLDER}"/"${HUGO_BIN##*/}" "${HUGO_BIN}"
        stow -d "${HUGO_STOW}" -R -v prebuilts
        rm -rf "${TMP_FOLDER}"
    fi
); }

# Install hub
function ihub() { (
    header "Installing hub"
    HUB_REPO=github/hub
    [[ -z ${HUB_VERSION} ]] && HUB_VERSION=$(glr ${HUB_REPO})
    case "$(uname -m)" in
        armv7l) ARCH=arm ;;
        aarch64)
            # The Raspberry Pi might be running a 64-bit kernel but 32-bit OS
            if command -v dpkg &>/dev/null; then
                case "$(dpkg --print-architecture)" in
                    armhf) ARCH=arm ;;
                    *) ARCH=arm64 ;;
                esac
            else
                ARCH=arm64
            fi
            ;;
        x86_64) ARCH=amd64 ;;
        *) die "Architecture not supported" ;;
    esac
    HUB_TUPLE="hub-linux-${ARCH}-${HUB_VERSION/v/}"
    cd "$(mktemp -d)" || die "Error moving into temporary directory!"
    curl -LSsO https://github.com/${HUB_REPO}/releases/download/"${HUB_VERSION}"/"${HUB_TUPLE}".tgz || die "Error downloading hub!"
    tar -xf "${HUB_TUPLE}".tgz || die "Error extracting hub!"
    HUB_STOW=${PREFIX:-${USR_FOLDER:?}}/stow
    prefix="${HUB_STOW}"/prebuilts ./"${HUB_TUPLE}"/install || die "Error installing hub!"
    if [[ -n ${ZSH_NAME} ]]; then
        mkdir -p "${HOME}"/.zfunctions
        curl -LSso "${HOME}"/.zfunctions/_hub https://github.com/${HUB_REPO}/raw/"${HUB_VERSION}"/etc/hub.zsh_completion
    fi
    stow -d "${HUB_STOW}" -R -v prebuilts
    rm -rf "${PWD}"
); }

# Install shellcheck
function ishellcheck() { (
    header "Installing shellcheck"
    SHCHK_REPO=koalaman/shellcheck
    [[ -z ${SHELLCHECK_VERSION} ]] && SHELLCHECK_VERSION=$(glr "${SHCHK_REPO}")
    SHCHK_FOLDER=$(mktemp -d)/shellcheck-v"${SHELLCHECK_VERSION//v/}"
    curl -LSs https://github.com/"${SHCHK_REPO}"/releases/download/"${SHELLCHECK_VERSION}"/"${SHCHK_FOLDER##*/}".linux.x86_64.tar.xz | tar -C "${SHCHK_FOLDER%/*}" -xJf - || exit ${?}
    SHCHK_STOW=${PREFIX:-${USR_FOLDER:?}}/stow
    install -Dm755 "${SHCHK_FOLDER}"/shellcheck "${SHCHK_STOW}"/prebuilts/bin/shellcheck || exit ${?}
    stow -d "${SHCHK_STOW}" -R -v prebuilts
    rm -rf "${SHCHK_FOLDER%/*}"
); }

# Install shfmt
function ishfmt() { (
    header "Installing shfmt"
    SHFMT_REPO=mvdan/sh
    [[ -z ${SHFMT_VERSION} ]] && SHFMT_VERSION=$(glr ${SHFMT_REPO})
    SHFMT_VERSION=v${SHFMT_VERSION//v/}

    SHFMT_STOW=${PREFIX:-${USR_FOLDER:?}}/stow
    SHFMT_BIN=${SHFMT_STOW}/prebuilts/bin/shfmt
    mkdir -p "${SHFMT_BIN%/*}"
    rm -rf "${SHFMT_BIN}"
    curl -LSso "${SHFMT_BIN}" https://github.com/${SHFMT_REPO}/releases/download/"${SHFMT_VERSION}"/shfmt_"${SHFMT_VERSION}"_linux_amd64 || die "Error downloading/installing shfmt"
    chmod +x "${SHFMT_BIN}"
    stow -d "${SHFMT_STOW}" -R -v prebuilts
); }

function ituxmake() { (
    TUXMAKE_SRC=${SRC_FOLDER:?}/tuxmake
    mkdir -p "${TUXMAKE_SRC%/*}"

    [[ -d ${TUXMAKE_SRC} ]] || git clone https://gitlab.com/Linaro/tuxmake.git "${TUXMAKE_SRC}"
    git -C "${TUXMAKE_SRC}" pull --rebase

    TUXMAKE_STOW=${PREFIX:-${USR_FOLDER:?}}/stow
    TUXMAKE_BIN=${TUXMAKE_STOW}/prebuilts/bin
    mkdir -p "${TUXMAKE_BIN}"
    ln -sf "${TUXMAKE_SRC}"/run "${TUXMAKE_BIN}"/tuxmake
    stow -d "${TUXMAKE_STOW}" -R -v prebuilts
); }

function irust() { (
    curl https://sh.rustup.rs -sSf | bash -s -- -y --no-modify-path
); }

# Install/upgrade b4
function ib4() { (
    header "Installing b4"

    B4_SRC=${SRC_FOLDER:?}/b4
    mkdir -p "${B4_SRC%/*}"

    [[ -d ${B4_SRC} ]] || git clone https://git.kernel.org/pub/scm/utils/b4/b4.git/ "${B4_SRC}"
    git -C "${B4_SRC}" pull --rebase

    B4_STOW=${PREFIX:-${USR_FOLDER:?}}/stow
    B4_BIN=${B4_STOW}/prebuilts/bin
    mkdir -p "${B4_BIN}"
    ln -sf "${B4_SRC}"/b4.sh "${B4_BIN}"/b4
    python3 -m pip install --requirement "${B4_SRC}"/requirements.txt --upgrade --user
    stow -d "${B4_STOW}" -R -v prebuilts
); }

# Main install function
function updbin() { (
    # git comes first in case we are rebuilding ~/usr from scratch
    # 'alias git=hub' can cause issues
    bgit || exit ${?}

    # Everything else is alphabetical
    bccache || exit ${?}
    bcmake || exit ${?}
    bcvise || exit ${?}
    bmake || exit ${?}
    bninja || exit ${?}
    biexa || exit ${?}
    birg || exit ${?}
    bisharkdp all || exit ${?}
    btmux || exit ${?}
    bzsh || exit ${?}
    ishellcheck || exit ${?}
    ishfmt || exit ${?}
); }
# vi: filetype=zsh
